diff --git a/Projects/WindowsPlayer/WindowsPlayer/WindowsPlayer.vcxproj b/Projects/WindowsPlayer/WindowsPlayer/WindowsPlayer.vcxproj
index c5d13ad..71966c5 100644
--- a/Projects/WindowsPlayer/WindowsPlayer/WindowsPlayer.vcxproj
+++ b/Projects/WindowsPlayer/WindowsPlayer/WindowsPlayer.vcxproj
@@ -72,7 +72,8 @@
     <IncludePath>C:\Users\Lukas-PC\Source\VoidEngine\Source\;$(IncludePath)</IncludePath>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <IncludePath>C:\Users\Lukas-PC\Source\VoidEngine\External\veclib;C:\Users\Lukas-PC\Source\VoidEngine\Source;$(IncludePath)</IncludePath>
+    <IncludePath>C:\Users\Lukas-PC\Source\VoidEngine\External\Windows Kit\10\Include\10.0.14393.0\um;C:\Users\Lukas-PC\Source\VoidEngine\External\Windows Kit\10\Include\10.0.14393.0\d3dx12;C:\Users\Lukas-PC\Source\VoidEngine\External\Windows Kit\10\Include\10.0.14393.0\shared;C:\Users\Lukas-PC\Source\VoidEngine\Source;$(IncludePath)</IncludePath>
+    <LibraryPath>C:\Users\Lukas-PC\Source\VoidEngine\External\Windows Kit\10\Lib\10.0.14393.0\um\x64;$(LibraryPath)</LibraryPath>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <IncludePath>C:\Users\Lukas-PC\Source\VoidEngine\External\Windows Kit\10\Include\10.0.14393.0\um;C:\Users\Lukas-PC\Source\VoidEngine\External\Windows Kit\10\Include\10.0.14393.0\d3dx12;C:\Users\Lukas-PC\Source\VoidEngine\External\Windows Kit\10\Include\10.0.14393.0\shared;C:\Users\Lukas-PC\Source\VoidEngine\External\veclib;C:\Users\Lukas-PC\Source\VoidEngine\Source;$(IncludePath)</IncludePath>
@@ -90,7 +91,7 @@
       <WarningLevel>Level3</WarningLevel>
       <Optimization>Disabled</Optimization>
       <SDLCheck>true</SDLCheck>
-      <PreprocessorDefinitions>__x86_64;DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <PreprocessorDefinitions>__x86_64;DEBUG;_HAS_ITERATOR_DEBUGGING;%(PreprocessorDefinitions)</PreprocessorDefinitions>
     </ClCompile>
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
diff --git a/Source/Common/Collections/List.h b/Source/Common/Collections/List.h
index e6eaacf..379e4ba 100644
--- a/Source/Common/Collections/List.h
+++ b/Source/Common/Collections/List.h
@@ -3,6 +3,7 @@
 #include <Common\EngineCommon.h>
 #include <vector>
 
+
 template<class T>
 class List : public std::vector<T>
 {
diff --git a/Source/Common/IOStream.h b/Source/Common/IOStream.h
index e8f9152..cad539f 100644
--- a/Source/Common/IOStream.h
+++ b/Source/Common/IOStream.h
@@ -43,12 +43,11 @@ public:
 		memcpy(data, this->data, size);
 		this->data += size;
 	}
-
 	template<typename T>
 	inline T& FastRead()
 	{
 		T& ptr = *(T*) data;
-		offset += sizeof(T);
+		this->data += sizeof(T);
 		return ptr;
 	}
 
diff --git a/Source/Common/Testing.h b/Source/Common/Testing.h
index be5d114..0815763 100644
--- a/Source/Common/Testing.h
+++ b/Source/Common/Testing.h
@@ -38,6 +38,11 @@
 		Console::Print("    In: " STRINGIFY_BUILTIN(__FILE__) " @ " STRINGIFY_BUILTIN(__LINE__) "\n"); \
 		__debugbreak(); \
 	}
+#else
+#	define ASSERT(isFalse) (void)(isFalse)
+#	define ASSERT_MSG(isFalse, ...) (void)(isFalse)
+#	define ERROR(...)
+#endif
 
 #	define TRACE(...) \
 	{ \
@@ -45,12 +50,6 @@
 		Console::Printf(__VA_ARGS__); \
 		Console::Print("\n"); \
 	}
-#else
-#	define ASSERT(isFalse) (void)(isFalse)
-#	define ASSERT_MSG(isFalse, ...) (void)(isFalse)
-#	define ERROR(...)
-#	define TRACE(...)
-#endif
 
 //#define EXT_DEBUG
 
diff --git a/Source/Foundation/TimeModule.cpp b/Source/Foundation/TimeModule.cpp
index e7a73f9..85daf6d 100644
--- a/Source/Foundation/TimeModule.cpp
+++ b/Source/Foundation/TimeModule.cpp
@@ -1,6 +1,5 @@
 #include <Foundation\TimeModule.h>
 #include <Math\Math.h>
-#include <stdarg.h>
 
 TimeModule::TimeModule() :
 	passedFrameCount(0)
@@ -11,8 +10,12 @@ TimeModule::TimeModule() :
 void TimeModule::Execute(const ExecutionContext & context)
 {
 	stopWatch.Stop();
-	if (stopWatch.GetElapsedMiliseconds() >= 1000)
+	if (stopWatch.GetElapsedMiliseconds() >= 8000)
 	{
+		// 78 58 59
+		// 69 59 61
+		// 67 57 57
+		// 36 33 33
 		TRACE("Frame took ms %f", (float) stopWatch.GetElapsedMiliseconds() / passedFrameCount);
 		stopWatch.Start();
 		passedFrameCount = 0;
diff --git a/Source/Graphics/D12/D12CmdQueue.cpp b/Source/Graphics/D12/D12CmdQueue.cpp
index 3fa93b6..12f83f9 100644
--- a/Source/Graphics/D12/D12CmdQueue.cpp
+++ b/Source/Graphics/D12/D12CmdQueue.cpp
@@ -73,13 +73,35 @@ void D12CmdQueue::Close(D12CmdBuffer* buffer)
 void D12CmdQueue::Execute(D12CmdBuffer* buffer, bool isLast)
 {
 	if (buffer->swapChain != nullptr)
+	{
+		if (!cmdsToExecute.empty())
+		{
+			queue->ExecuteCommandLists(cmdsToExecute.size(), cmdsToExecute.data());
+			//queue->Signal(fence, buffer->index);
+			//queue->ExecuteCommandLists(1/*cmds.size()*/, cmds.data() + 1);
+			cmdsToExecute.clear();
+		}
+
 		buffer->swapChain->Present(1, 0);
+
+		if (isLast)
+			queue->Signal(fence, buffer->index);
+	}
 	else
 	{
-		ASSERT_SUCCEEDED(buffer->commandList != nullptr);
-		queue->ExecuteCommandLists(1, (ID3D12CommandList**) &buffer->commandList);
+		cmdsToExecute.push_back(buffer->commandList);
+
+		if (isLast)
+		{
+			queue->ExecuteCommandLists(cmdsToExecute.size(), cmdsToExecute.data());
+			cmdsToExecute.clear();
+			queue->Signal(fence, buffer->index);
+		}
+
+		//ASSERT_SUCCEEDED(buffer->commandList != nullptr);
+		//queue->ExecuteCommandLists(1, (ID3D12CommandList**) &buffer->commandList);
+		//queue->Signal(fence, buffer->index);
 	}
-	queue->Signal(fence, buffer->index);
 }
 
 uint64_t D12CmdQueue::GetCompletedBufferIndex()
diff --git a/Source/Graphics/D12/D12CmdQueue.h b/Source/Graphics/D12/D12CmdQueue.h
index b8f7467..1769a63 100644
--- a/Source/Graphics/D12/D12CmdQueue.h
+++ b/Source/Graphics/D12/D12CmdQueue.h
@@ -23,7 +23,7 @@ struct D12CmdBuffer
 		this->index = index;
 		swapChain = nullptr;
 		stream.Reset();
-		memset(heaps, 0, kD12HeapTypeCount * sizeof(D12Heap*));
+		memset(heaps, 0, D12HeapTypeCount * sizeof(D12Heap*));
 	}
 
 	const D3D12_COMMAND_LIST_TYPE type;
@@ -33,7 +33,7 @@ struct D12CmdBuffer
 	ID3D12GraphicsCommandList* commandList;
 	IDXGISwapChain* swapChain;
 	uint64_t index;
-	D12Heap* heaps[kD12HeapTypeCount];
+	D12Heap* heaps[D12HeapTypeCount];
 };
 
 class D12CmdQueue
@@ -61,6 +61,7 @@ private:
 
 	List<D12CmdBuffer*> buffers;
 	std::queue<D12CmdBuffer*> readyBuffers;
-	D12CmdAllocatorPool* allocatorPool;
 	uint64_t pulledBufferCount;
+
+	List<ID3D12CommandList*> cmdsToExecute;
 };
\ No newline at end of file
diff --git a/Source/Graphics/D12/D12Common.h b/Source/Graphics/D12/D12Common.h
index 7f1cb85..6504cda 100644
--- a/Source/Graphics/D12/D12Common.h
+++ b/Source/Graphics/D12/D12Common.h
@@ -22,9 +22,7 @@ using Microsoft::WRL::ComPtr;
 #define D12_DEBUG_TRACE(...)
 #endif
 
-#ifdef RELEASE
-#define ASSERT_SUCCEEDED(hr) (void)(hr)
-#else
+#ifdef DEBUG
 #define ASSERT_SUCCEEDED(hr) \
 	if (FAILED(hr)) \
 	{ \
@@ -38,4 +36,6 @@ using Microsoft::WRL::ComPtr;
 		Console::Print("\n"); \
 		__debugbreak(); \
 	}
+#else
+	#define ASSERT_SUCCEEDED(hr) (void)(hr)
 #endif
\ No newline at end of file
diff --git a/Source/Graphics/D12/D12GraphicsExecuterModule.cpp b/Source/Graphics/D12/D12GraphicsExecuterModule.cpp
index d06cc41..8251cb0 100644
--- a/Source/Graphics/D12/D12GraphicsExecuterModule.cpp
+++ b/Source/Graphics/D12/D12GraphicsExecuterModule.cpp
@@ -9,7 +9,7 @@ D12GraphicsExecuterModule::D12GraphicsExecuterModule(uint32_t workersCount) :
 {
 }
 
-void D12GraphicsExecuterModule::RecordCmdBuffer(const ExecutionContext& context, const D12CmdBuffer* buffer)
+void D12GraphicsExecuterModule::RecCmdBuffer(const ExecutionContext& context, const D12CmdBuffer* buffer)
 {
 	auto& executerContext = executerContexts[context.workerIndex];
 	executerContext.recordedCmds.push_back(buffer);
@@ -36,6 +36,6 @@ void D12GraphicsExecuterModule::Execute(const ExecutionContext& context)
 
 	// TODO: remove onc we have buffer caching
 	if (!cmdBuffersToExecute.empty())
-		cmdBuffersToExecute.back()->queue->WaitForBufferIndexToComplete(cmdBuffersToExecute.back()->index);
-	completedBufferIndex = cmdBuffersToExecute.back()->index;
+		cmdBuffersToExecute.back()->queue->WaitForBufferIndexToComplete(back->index);
+	completedBufferIndex = back->index;
 }
\ No newline at end of file
diff --git a/Source/Graphics/D12/D12GraphicsExecuterModule.h b/Source/Graphics/D12/D12GraphicsExecuterModule.h
index 150821b..025e50a 100644
--- a/Source/Graphics/D12/D12GraphicsExecuterModule.h
+++ b/Source/Graphics/D12/D12GraphicsExecuterModule.h
@@ -13,15 +13,15 @@ public:
 	virtual void Execute(const ExecutionContext& context) override;
 	virtual const char* GetName() override { return "D12GraphicsExecuterModule"; }
 
-	void RecordCmdBuffer(const ExecutionContext& context, const D12CmdBuffer* buffer);
+	void RecCmdBuffer(const ExecutionContext& context, const D12CmdBuffer* buffer);
 
 private:
 	struct Context
 	{
 		List<const D12CmdBuffer*> recordedCmds;
 	};
-
 	List<Context> executerContexts;
+
 	List<const D12CmdBuffer*> cmdBuffersToExecute;
 	List<ID3D12GraphicsCommandList*> batchedCommandLists;
 	AUTOMATED_PROPERTY_GET(uint64_t, completedBufferIndex);
diff --git a/Source/Graphics/D12/D12GraphicsModule.cpp b/Source/Graphics/D12/D12GraphicsModule.cpp
index 7cf5b59..d8ec191 100644
--- a/Source/Graphics/D12/D12GraphicsModule.cpp
+++ b/Source/Graphics/D12/D12GraphicsModule.cpp
@@ -62,7 +62,7 @@ SERIALIZE_METHOD_CREATEGEN_ARG1(D12GraphicsModule, IBuffer, D12Buffer, size_t);
 SERIALIZE_METHOD_ARG3(D12GraphicsModule, UpdateBuffer, const IBuffer*, void*, size_t);
 SERIALIZE_METHOD_ARG1(D12GraphicsModule, PushDebug, const char*);
 SERIALIZE_METHOD(D12GraphicsModule, PopDebug);
-SERIALIZE_METHOD_ARG1(D12GraphicsModule, BindDrawSimple, const DrawSimple&);
+SERIALIZE_METHOD_ARG1(D12GraphicsModule, Draw, const DrawDesc&);
 
 bool D12GraphicsModule::ExecuteCommand(const ExecutionContext& context, IOStream& stream, uint32_t commandCode)
 {
@@ -121,18 +121,18 @@ bool D12GraphicsModule::ExecuteCommand(const ExecutionContext& context, IOStream
 		DESERIALIZE_METHOD_END;
 
 		DESERIALIZE_METHOD_ARG2_START(Present, D12SwapChain*, target, D12Texture*, texture);
-		planner->RecordPresent(target);
-		target->backBufferIndex = (target->backBufferIndex + 1) % target->backBufferCount;
+		planner->RecPresent(target);
+		target->bacBufferIndex = (target->bacBufferIndex + 1) % target->bacBufferCount;
 		DESERIALIZE_METHOD_END;
 
 		DESERIALIZE_METHOD_ARG2_START(FinalBlit, D12SwapChain*, target, D12Texture*, texture);
 		// Blit ofscreen buffer to swapchain backbuffer
-		auto backBuffer = target->GetBackBuffer();
-		BlitCopy(context, texture, backBuffer);
+		auto bacBuffer = target->GetBacBuffer();
+		BlitCopy(context, texture, bacBuffer);
 
-		ASSERT(target->backBufferIndex == target->IDXGISwapChain3->GetCurrentBackBufferIndex());
+		ASSERT(target->bacBufferIndex == target->IDXGISwapChain3->GetCurrentBackBufferIndex());
 
-		SetTextureState(context, backBuffer, D3D12_RESOURCE_STATE_PRESENT);
+		SetTextureState(context, bacBuffer, D3D12_RESOURCE_STATE_PRESENT);
 		DESERIALIZE_METHOD_END;
 
 		DESERIALIZE_METHOD_ARG1_START(CreateIBuffer, D12Buffer*, target);
@@ -144,15 +144,15 @@ bool D12GraphicsModule::ExecuteCommand(const ExecutionContext& context, IOStream
 		DESERIALIZE_METHOD_END;
 
 		DESERIALIZE_METHOD_ARG1_START(PushDebug, const char*, name);
-		planner->RecordPushDebug(name);
+		planner->RecPushDebug(name);
 		DESERIALIZE_METHOD_END;
 
 		DESERIALIZE_METHOD_START(PopDebug);
-		planner->RecordPopDebug();
+		planner->RecPopDebug();
 		DESERIALIZE_METHOD_END;
 
-		DESERIALIZE_METHOD_ARG1_START(BindDrawSimple, DrawSimple, target);
-		BindDrawSimple(context, target);
+		DESERIALIZE_METHOD_ARG1_START(Draw, DrawDesc, target);
+		Draw(context, target);
 		DESERIALIZE_METHOD_END;
 	}
 	return false;
@@ -164,7 +164,7 @@ void D12GraphicsModule::SetTextureState(const ExecutionContext& context, D12Text
 		return;
 
 	ASSERT(target->resource != nullptr);
-	planner->RecordSetTextureState(target, target->currentState, state);
+	planner->RecSetTextureState(target, target->currentState, state);
 	target->currentState = state;
 }
 
@@ -174,7 +174,7 @@ void D12GraphicsModule::SetBufferState(const ExecutionContext& context, D12Buffe
 		return;
 
 	ASSERT(target->resource != nullptr);
-	planner->RecordSetBufferState(target, target->currentState, state);
+	planner->RecSetBufferState(target, target->currentState, state);
 	target->currentState = state;
 }
 
@@ -190,7 +190,7 @@ void D12GraphicsModule::SetBuffer(D12ShaderArguments* target, const char* name,
 		auto& rootParameter = rootParameters[i];
 		switch (rootParameter.type)
 		{
-		/*case kD12RootParamterTypeTableSRV:
+		/*case D12RootParamterTypeTableSRV:
 		{
 			for (size_t j = 0; j < rootParameter.supParameters.size(); j++)
 			{
@@ -218,7 +218,7 @@ void D12GraphicsModule::SetBuffer(D12ShaderArguments* target, const char* name,
 			break;
 		}*/
 
-		case kD12RootParamterTypeConstantBuffer:
+		case D12RootParamterTypeConstantBuffer:
 		{
 			auto& rootSubParameter = rootParameter.supParameters[0];
 			if (strcmp(rootSubParameter.name, name) != 0)
@@ -243,7 +243,7 @@ void D12GraphicsModule::SetTexture(D12ShaderArguments* target, const char* name,
 		auto& rootArgument = rootArguments[i];
 		switch (rootParameter.type)
 		{
-		case kD12RootParamterTypeTableSRV:
+		case D12RootParamterTypeTableSRV:
 		{
 			for (size_t j = 0; j < rootParameter.supParameters.size(); j++)
 			{
@@ -305,7 +305,7 @@ void D12GraphicsModule::SetFilter(D12ShaderArguments* target, const char* name,
 		auto& rootArgument = rootArguments[i];
 		switch (rootParameter.type)
 		{
-		case kD12RootParamterTypeTableSamplers:
+		case D12RootParamterTypeTableSamplers:
 		{
 			for (size_t j = 0; j < rootParameter.supParameters.size(); j++)
 			{
@@ -414,17 +414,22 @@ void D12GraphicsModule::SetRenderPass(const ExecutionContext & context, const D1
 	{
 		SetTextureState(context, depthTexture, D3D12_RESOURCE_STATE_DEPTH_WRITE);
 	}
-	planner->RecordSetHeap(srvHeap);
-	planner->RecordSetHeap(samplersHeap);
-	planner->RecordSetRenderPass(target);
+	D12Heap* heaps[D12HeapTypeCount] = {
+		srvHeap,
+		samplersHeap,
+		nullptr,
+		nullptr,
+		nullptr};
+	planner->RecSetHeap((const D12Heap**) heaps);
+	planner->RecSetRenderPass(target);
 }
 
 void D12GraphicsModule::UpdateBuffer(D12Buffer* target, uint32_t targetOffset, Range<uint8_t> data)
 {
-	planner->RecordUpdateBuffer(target, targetOffset, data);
+	planner->RecUpdateBuffer(target, targetOffset, data);
 }
 
-inline void D12GraphicsModule::BindDrawSimple(const ExecutionContext& context, const DrawSimple& target)
+inline void D12GraphicsModule::Draw(const ExecutionContext& context, const DrawDesc& target)
 {
 	auto pipeline = (D12ShaderPipeline*) target.pipeline;
 	auto arguments = (D12ShaderArguments*) target.properties;
@@ -435,7 +440,7 @@ inline void D12GraphicsModule::BindDrawSimple(const ExecutionContext& context, c
 		auto& rootParameter = rootParameters[i];
 		switch (rootParameter.type)
 		{
-		case kD12RootParamterTypeTableSRV:
+		case D12RootParamterTypeTableSRV:
 		{
 			auto& rootArgument = rootArguments[i];
 			for (size_t j = 0; j < rootParameter.supParameters.size(); j++)
@@ -455,7 +460,7 @@ inline void D12GraphicsModule::BindDrawSimple(const ExecutionContext& context, c
 			}
 			break;
 		}
-		case kD12RootParamterTypeTableSamplers:
+		case D12RootParamterTypeTableSamplers:
 		{
 			auto& rootArgument = rootArguments[i];
 			rootArgument.IsCurrentlyUsedByDraw = true;
@@ -463,7 +468,7 @@ inline void D12GraphicsModule::BindDrawSimple(const ExecutionContext& context, c
 		}
 		}
 	}
-	planner->RecordDrawSimple(target);
+	planner->RecDraw(target);
 }
 
 void D12GraphicsModule::SetName(ID3D12Object* object, const wchar_t* format, ...)
@@ -485,33 +490,33 @@ void D12GraphicsModule::BlitCopy(const ExecutionContext& context, D12Texture* sr
 		InitializeBlitCopy(blitCopy);
 	}
 
-	SetColorAttachment(context, blitCopy->renderPass, 0, ColorAttachment(dest, kStoreActionStore, kLoadActionDontCare));
+	SetColorAttachment(context, blitCopy->renderPass, 0, ColorAttachment(dest, StoreActionStore, LoadActionDontCare));
 	SetRenderPass(context, blitCopy->renderPass);
 
-	SetTexture((D12ShaderArguments*) blitCopy->properties, "_MainTex", src);
-	BindDrawSimple(context, *blitCopy);
+	SetTexture((D12ShaderArguments*) blitCopy->properties, "_mainTex", src);
+	Draw(context, *blitCopy);
 }
 
 void D12GraphicsModule::Present(const ExecutionContext& context, D12SwapChain* swapChain, D12Texture* offscreen)
 {
-	planner->RecordRequestSplit();
+	planner->RecRequestSplit();
 
 	// Blit ofscreen buffer to swapchain backbuffer
-	auto backBuffer = swapChain->GetBackBuffer();
-	BlitCopy(context, offscreen, backBuffer);
+	auto bacBuffer = swapChain->GetBacBuffer();
+	BlitCopy(context, offscreen, bacBuffer);
 
-	ASSERT(swapChain->backBufferIndex == swapChain->IDXGISwapChain3->GetCurrentBackBufferIndex());
+	ASSERT(swapChain->bacBufferIndex == swapChain->IDXGISwapChain3->GetCurrentBackBufferIndex());
 
 	// Present backbuffer on screen
-	SetTextureState(context, backBuffer, D3D12_RESOURCE_STATE_PRESENT);
-	planner->RecordPresent(swapChain);
+	SetTextureState(context, bacBuffer, D3D12_RESOURCE_STATE_PRESENT);
+	planner->RecPresent(swapChain);
 
-	swapChain->backBufferIndex = (swapChain->backBufferIndex + 1) % swapChain->backBufferCount;
+	swapChain->bacBufferIndex = (swapChain->bacBufferIndex + 1) % swapChain->bacBufferCount;
 }
 
 bool D12GraphicsModule::Initialize()
 {
-	UINT dxgiFactoryFlags;
+	UINT dxgiFactoryFlags = 0;
 #if defined(_DEBUG)
 	// Enable the debug layer (requires the Graphics Tools "optional feature").
 	// NOTE: Enabling the debug layer after device creation will invalidate the active device.
@@ -538,16 +543,16 @@ bool D12GraphicsModule::Initialize()
 	if (FAILED(result))
 		return false;
 
-	// This is the highest version the sample supports. If CheckFeatureSupport succeeds, the HighestVersion returned will not be greater than this.
+	// This is the highest version the sample supports. If ChecFeatureSupport succeeds, the HighestVersion returned will not be greater than this.
 	rootSignatureFeatures.HighestVersion = D3D_ROOT_SIGNATURE_VERSION_1_1;
 	if (FAILED(device->CheckFeatureSupport(D3D12_FEATURE_ROOT_SIGNATURE, &rootSignatureFeatures, sizeof(rootSignatureFeatures))))
 		rootSignatureFeatures.HighestVersion = D3D_ROOT_SIGNATURE_VERSION_1_0;
 
-	srvHeap = new D12Heap(device, kD12HeapTypeSRVs, 100);
-	rtvHeap = new D12Heap(device, kD12HeapTypeRTVs, 100);
-	samplersHeap = new D12Heap(device, kD12HeapTypeSamplers, 100);
-	srvCpuHeap = new D12Heap(device, kD12HeapTypeSRVsCPU, 100);
-	samplersCpuHeap = new D12Heap(device, kD12HeapTypeSamplersCPU, 100);
+	srvHeap = new D12Heap(device, D12HeapTypeSRVs, 100);
+	rtvHeap = new D12Heap(device, D12HeapTypeRTVs, 100);
+	samplersHeap = new D12Heap(device, D12HeapTypeSamplers, 100);
+	srvCpuHeap = new D12Heap(device, D12HeapTypeSRVsCPU, 100);
+	samplersCpuHeap = new D12Heap(device, D12HeapTypeSamplersCPU, 100);
 
 	ID3D12CommandAllocator* alloc;
 	ASSERT_SUCCEEDED(device->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&alloc)));
@@ -560,14 +565,14 @@ bool D12GraphicsModule::Initialize()
 void D12GraphicsModule::InitializeSwapCain(D12SwapChain* swapChain)
 {
 	auto view = swapChain->view;
-	auto backBufferCount = swapChain->backBufferCount;
+	auto bacBufferCount = swapChain->bacBufferCount;
 
 	swapChain->width = view->width;
 	swapChain->height = view->height;
 
 	// Describe and create the swap chain.
 	DXGI_SWAP_CHAIN_DESC1 swapChainDesc = {};
-	swapChainDesc.BufferCount = backBufferCount;
+	swapChainDesc.BufferCount = bacBufferCount;
 	swapChainDesc.Width = swapChain->width;
 	swapChainDesc.Height = swapChain->height;
 	swapChainDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
@@ -594,27 +599,27 @@ void D12GraphicsModule::InitializeSwapCain(D12SwapChain* swapChain)
 
 	ASSERT_SUCCEEDED(swapChain1->QueryInterface(IID_PPV_ARGS(&swapChain->IDXGISwapChain3)));
 	auto d12SwapChain = swapChain->IDXGISwapChain3;
-	swapChain->backBufferIndex = d12SwapChain->GetCurrentBackBufferIndex();
+	swapChain->bacBufferIndex = d12SwapChain->GetCurrentBackBufferIndex();
 
-	auto memory = rtvHeap->Allocate(backBufferCount);
+	auto memory = rtvHeap->Allocate(bacBufferCount);
 
 	// Create backbuffers
-	swapChain->backBuffers = new D12Texture*[backBufferCount];
-	for (uint32_t i = 0; i < backBufferCount; i++)
+	swapChain->bacBuffers = new D12Texture*[bacBufferCount];
+	for (uint32_t i = 0; i < bacBufferCount; i++)
 	{
-		auto backBufferMemory = D12HeapMemory(memory.pointer + i, 1);
-
-		ID3D12Resource* backBufferResource;
-		ASSERT_SUCCEEDED(d12SwapChain->GetBuffer(i, IID_PPV_ARGS(&backBufferResource)));
-		device->CreateRenderTargetView(backBufferResource, nullptr, rtvHeap->GetCpuHandle(backBufferMemory));
-
-		auto backBuffer = new D12Texture(swapChain->width, swapChain->height);
-		backBuffer->usage = kTextureUsageFlagRender;
-		backBuffer->rtvMemory = backBufferMemory;
-		backBuffer->resource = backBufferResource;
-		backBuffer->currentState = D3D12_RESOURCE_STATE_PRESENT;
-		swapChain->backBuffers[i] = backBuffer;
-		SetName(backBufferResource, L"BackBuffer %d (SwapChain %d)", i, resourceCounter);
+		auto bacBufferMemory = D12HeapMemory(memory.pointer + i, 1);
+
+		ID3D12Resource* bacBufferResource;
+		ASSERT_SUCCEEDED(d12SwapChain->GetBuffer(i, IID_PPV_ARGS(&bacBufferResource)));
+		device->CreateRenderTargetView(bacBufferResource, nullptr, rtvHeap->GetCpuHandle(bacBufferMemory));
+
+		auto bacBuffer = new D12Texture(swapChain->width, swapChain->height);
+		bacBuffer->usage = TextureUsageFlagRender;
+		bacBuffer->rtvMemory = bacBufferMemory;
+		bacBuffer->resource = bacBufferResource;
+		bacBuffer->currentState = D3D12_RESOURCE_STATE_PRESENT;
+		swapChain->bacBuffers[i] = bacBuffer;
+		SetName(bacBufferResource, L"BacBuffer %d (SwapChain %d)", i, resourceCounter);
 	}
 }
 
@@ -626,7 +631,7 @@ void D12GraphicsModule::InitializeTexture(D12Texture* texture)
 	textureDesc.Width = texture->width;
 	textureDesc.Height = texture->height;
 	textureDesc.Flags = D3D12_RESOURCE_FLAG_NONE;
-	if (texture->usage & kTextureUsageFlagRender)
+	if (texture->usage & TextureUsageFlagRender)
 		textureDesc.Flags |= D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET;
 	textureDesc.DepthOrArraySize = 1;
 	textureDesc.SampleDesc.Count = 1;
@@ -637,7 +642,7 @@ void D12GraphicsModule::InitializeTexture(D12Texture* texture)
 	bool useClearVlaue = false;
 
 	// If we match the clear values with render pass, we win performance
-	if (texture->usage & kTextureUsageFlagRender)
+	if (texture->usage & TextureUsageFlagRender)
 	{
 		clearValue.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
 		clearValue.Color[0] = 0;
@@ -656,7 +661,7 @@ void D12GraphicsModule::InitializeTexture(D12Texture* texture)
 		IID_PPV_ARGS(&texture->resource)));
 
 	// Create SRV
-	if (texture->usage & kTextureUsageFlagShader)
+	if (texture->usage & TextureUsageFlagShader)
 	{
 		texture->srvMemory = srvCpuHeap->Allocate(1);
 		D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {};
@@ -668,7 +673,7 @@ void D12GraphicsModule::InitializeTexture(D12Texture* texture)
 	}
 
 	// Create RTV
-	if (texture->usage & kTextureUsageFlagRender)
+	if (texture->usage & TextureUsageFlagRender)
 	{
 		texture->rtvMemory = rtvHeap->Allocate(1);
 		device->CreateRenderTargetView(texture->resource, nullptr, rtvHeap->GetCpuHandle(texture->rtvMemory));
@@ -734,11 +739,11 @@ void D12GraphicsModule::CompilePipeline(D12ShaderPipeline* pipeline)
 	if (error.Get() != NULL)
 		ERROR((const char*) error.Get()->GetBufferPointer());
 
-	pipeline->programs[kShaderProgramTypeVertex] = ShaderProgram(new uint8_t[vertexShader.Get()->GetBufferSize()], vertexShader.Get()->GetBufferSize());
-	pipeline->programs[kShaderProgramTypeFragment] = ShaderProgram(new uint8_t[pixelShader.Get()->GetBufferSize()], pixelShader.Get()->GetBufferSize());
+	pipeline->programs[ShaderProgramTypeVertex] = ShaderProgram(new uint8_t[vertexShader.Get()->GetBufferSize()], vertexShader.Get()->GetBufferSize());
+	pipeline->programs[ShaderProgramTypeFragment] = ShaderProgram(new uint8_t[pixelShader.Get()->GetBufferSize()], pixelShader.Get()->GetBufferSize());
 
-	memcpy((void*) pipeline->programs[kShaderProgramTypeVertex].code, (const uint8_t*) vertexShader.Get()->GetBufferPointer(), vertexShader.Get()->GetBufferSize());
-	memcpy((void*) pipeline->programs[kShaderProgramTypeFragment].code, (const uint8_t*) pixelShader.Get()->GetBufferPointer(), pixelShader.Get()->GetBufferSize());
+	memcpy((void*) pipeline->programs[ShaderProgramTypeVertex].code, (const uint8_t*) vertexShader.Get()->GetBufferPointer(), vertexShader.Get()->GetBufferSize());
+	memcpy((void*) pipeline->programs[ShaderProgramTypeFragment].code, (const uint8_t*) pixelShader.Get()->GetBufferPointer(), pixelShader.Get()->GetBufferSize());
 }
 
 void D12GraphicsModule::InitializePipeline(D12ShaderPipeline* pipeline)
@@ -755,17 +760,17 @@ void D12GraphicsModule::InitializePipeline(D12ShaderPipeline* pipeline)
 	ComPtr<ID3DBlob> vertexShader;
 	ComPtr<ID3DBlob> fragmentShader;
 	{
-		if (pipeline->programs[kShaderProgramTypeVertex].available)
+		if (pipeline->programs[ShaderProgramTypeVertex].available)
 		{
-			auto shaderProgram = pipeline->programs[kShaderProgramTypeVertex];
+			auto shaderProgram = pipeline->programs[ShaderProgramTypeVertex];
 			ASSERT_SUCCEEDED(D3DCreateBlob(shaderProgram.size, &vertexShader));
 			memcpy(vertexShader.Get()->GetBufferPointer(), shaderProgram.code, shaderProgram.size);
 			psoDesc.VS = CD3DX12_SHADER_BYTECODE(vertexShader.Get());
 		}
 
-		if (pipeline->programs[kShaderProgramTypeFragment].available)
+		if (pipeline->programs[ShaderProgramTypeFragment].available)
 		{
-			auto shaderProgram = pipeline->programs[kShaderProgramTypeFragment];
+			auto shaderProgram = pipeline->programs[ShaderProgramTypeFragment];
 			ASSERT_SUCCEEDED(D3DCreateBlob(shaderProgram.size, &fragmentShader));
 			memcpy(fragmentShader.Get()->GetBufferPointer(), shaderProgram.code, shaderProgram.size);
 			psoDesc.PS = CD3DX12_SHADER_BYTECODE(fragmentShader.Get());
@@ -780,26 +785,26 @@ void D12GraphicsModule::InitializePipeline(D12ShaderPipeline* pipeline)
 		{
 			switch (parameter.type)
 			{
-			case kShaderParameterTypeConstantBuffer:
+			case ShaderParameterTypeConstantBuffer:
 			{
 				rootParameters.push_back(D12RootParamter::AsConstantBuffer(parameter.name.c_str()));
 				break;
 			}
-			case kShaderParameterTypeBuffer:
+			case ShaderParameterTypeBuffer:
 			{
-				auto& rootParamter = pipeline->FindRootParameter(kD12RootParamterTypeTableSRV);
+				auto& rootParamter = pipeline->FindRootParameter(D12RootParamterTypeTableSRV);
 				rootParamter.supParameters.push_back(D12RootSubParamter(parameter.name.c_str(), D3D12_DESCRIPTOR_RANGE_TYPE_SRV));
 				break;
 			}
-			case kShaderParameterTypeTexture:
+			case ShaderParameterTypeTexture:
 			{
-				auto& rootParamter = pipeline->FindRootParameter(kD12RootParamterTypeTableSRV);
+				auto& rootParamter = pipeline->FindRootParameter(D12RootParamterTypeTableSRV);
 				rootParamter.supParameters.push_back(D12RootSubParamter(parameter.name.c_str(), D3D12_DESCRIPTOR_RANGE_TYPE_SRV, true));
 				break;
 			}
-			case kShaderParameterTypeSampler:
+			case ShaderParameterTypeSampler:
 			{
-				auto& rootParamter = pipeline->FindRootParameter(kD12RootParamterTypeTableSamplers);
+				auto& rootParamter = pipeline->FindRootParameter(D12RootParamterTypeTableSamplers);
 				rootParamter.supParameters.push_back(D12RootSubParamter(parameter.name.c_str(), D3D12_DESCRIPTOR_RANGE_TYPE_SAMPLER));
 				break;
 			}
@@ -811,12 +816,12 @@ void D12GraphicsModule::InitializePipeline(D12ShaderPipeline* pipeline)
 			auto& rootParameter = rootParameters[i];
 			switch (rootParameter.type)
 			{
-			case kD12RootParamterTypeConstantBuffer:
+			case D12RootParamterTypeConstantBuffer:
 			{
 				d12RootParameters[i].InitAsConstantBufferView(i, 0U, D3D12_ROOT_DESCRIPTOR_FLAG_DATA_VOLATILE, D3D12_SHADER_VISIBILITY_ALL);
 				break;
 			}
-			case kD12RootParamterTypeTableSRV:
+			case D12RootParamterTypeTableSRV:
 			{
 				uint32_t srvCount = 0;
 				rootParameter.GetCounts(&srvCount, nullptr);
@@ -827,7 +832,7 @@ void D12GraphicsModule::InitializePipeline(D12ShaderPipeline* pipeline)
 				d12RootParameters[i].InitAsDescriptorTable(1, ranges, D3D12_SHADER_VISIBILITY_ALL);
 				break;
 			}
-			case kD12RootParamterTypeTableSamplers:
+			case D12RootParamterTypeTableSamplers:
 			{
 				uint32_t samplersCount = 0;
 				rootParameter.GetCounts(nullptr, &samplersCount);
@@ -903,19 +908,19 @@ void D12GraphicsModule::InitializeProperties(D12ShaderArguments* target)
 	{
 		switch (rootParameter.type)
 		{
-		case kD12RootParamterTypeTableSRV:
+		case D12RootParamterTypeTableSRV:
 		{
 			auto memory = srvHeap->Allocate(rootParameter.supParameters.size());
 			rootArguments.push_back(D12RootArgument(memory));
 			break;
 		}
-		case kD12RootParamterTypeTableSamplers:
+		case D12RootParamterTypeTableSamplers:
 		{
 			auto memory = samplersHeap->Allocate(rootParameter.supParameters.size());
 			rootArguments.push_back(D12RootArgument(memory));
 			break;
 		}
-		case kD12RootParamterTypeConstantBuffer:
+		case D12RootParamterTypeConstantBuffer:
 		{
 			rootArguments.push_back(D12RootArgument(0));
 			break;
@@ -941,8 +946,8 @@ struct VertData
 	float2 uv : TEXCOORD;
 };
 
-Texture2D _MainTex : register(t0);
-SamplerState _MainTexSampler : register(s0);
+Texture2D _mainTex : register(t0);
+SamplerState _mainTexSampler : register(s0);
 
 VertData VertMain(AppData i)
 {
@@ -954,24 +959,24 @@ VertData VertMain(AppData i)
 
 float4 FragMain(VertData i) : SV_TARGET
 {
-	return _MainTex.Sample(_MainTexSampler, float2(i.uv.x, 1 - i.uv.y));
+	return _mainTex.Sample(_mainTexSampler, float2(i.uv.x, 1 - i.uv.y));
 }
 			)";
 
 	VertexLayout vertexLayout;
-	vertexLayout.attributes.push_back(VertexAttributeLayout(kVertexAttributeTypePosition, kColorFormatR32G32B32));
-	vertexLayout.attributes.push_back(VertexAttributeLayout(kVertexAttributeTypeTexCoord0, kColorFormatR32G32));
+	vertexLayout.attributes.push_back(VertexAttributeLayout(VertexAttributeTypePosition, ColorFormatR32G32B32));
+	vertexLayout.attributes.push_back(VertexAttributeLayout(VertexAttributeTypeTexCoord0, ColorFormatR32G32));
 
 	auto shaderDesc = new ShaderPipelineDesc();
 	shaderDesc->name = "Test";
 	shaderDesc->source = (const uint8_t*) source;
 	shaderDesc->sourceSize = strlen(source);
-	shaderDesc->states.zTest = kZTestLEqual;
-	shaderDesc->states.zWrite = kZWriteOn;
+	shaderDesc->states.zTest = ZTestLEqual;
+	shaderDesc->states.zWrite = ZWriteOn;
 	shaderDesc->varation = 0;
 	shaderDesc->vertexLayout = vertexLayout;
-	shaderDesc->parameters.push_back(ShaderParameter("_MainTex", kShaderParameterTypeTexture));
-	shaderDesc->parameters.push_back(ShaderParameter("_MainTexSampler", kShaderParameterTypeSampler));
+	shaderDesc->parameters.push_back(ShaderParameter("_mainTex", ShaderParameterTypeTexture));
+	shaderDesc->parameters.push_back(ShaderParameter("_mainTexSampler", ShaderParameterTypeSampler));
 	target->pipeline = new D12ShaderPipeline(shaderDesc);
 	InitializePipeline((D12ShaderPipeline*)target->pipeline);
 
@@ -999,7 +1004,7 @@ float4 FragMain(VertData i) : SV_TARGET
 
 	target->filter = new D12Filter(FilterOptions());
 	InitializeFilter(target->filter);
-	SetFilter((D12ShaderArguments*) target->properties, "_MainTexSampler", target->filter);
+	SetFilter((D12ShaderArguments*) target->properties, "_mainTexSampler", target->filter);
 }
 
 DXGI_FORMAT D12GraphicsModule::Convert(ColorFormat format)
@@ -1007,11 +1012,11 @@ DXGI_FORMAT D12GraphicsModule::Convert(ColorFormat format)
 	// TODO: Table lookup
 	switch (format)
 	{
-	case kColorFormatR32G32B32A32:
+	case ColorFormatR32G32B32A32:
 		return DXGI_FORMAT_R32G32B32A32_FLOAT;
-	case kColorFormatR32G32B32:
+	case ColorFormatR32G32B32:
 		return DXGI_FORMAT_R32G32B32_FLOAT;
-	case kColorFormatR32G32:
+	case ColorFormatR32G32:
 		return DXGI_FORMAT_R32G32_FLOAT;
 	}
 	
@@ -1024,9 +1029,9 @@ const char* D12GraphicsModule::Convert(VertexAttributeType type)
 	// TODO: Table lookup
 	switch (type)
 	{
-	case kVertexAttributeTypePosition:
+	case VertexAttributeTypePosition:
 		return "POSITION";
-	case kVertexAttributeTypeTexCoord0:
+	case VertexAttributeTypeTexCoord0:
 		return "TEXCOORD";
 	}
 
@@ -1038,11 +1043,11 @@ uint32_t D12GraphicsModule::GetSize(ColorFormat format)
 {
 	switch (format)
 	{
-	case kColorFormatR32G32B32A32:
+	case ColorFormatR32G32B32A32:
 		return sizeof(float) * 4;
-	case kColorFormatR32G32B32:
+	case ColorFormatR32G32B32:
 		return sizeof(float) * 3;
-	case kColorFormatR32G32:
+	case ColorFormatR32G32:
 		return sizeof(float) * 2;
 	}
 
diff --git a/Source/Graphics/D12/D12GraphicsModule.h b/Source/Graphics/D12/D12GraphicsModule.h
index a4845b7..2240388 100644
--- a/Source/Graphics/D12/D12GraphicsModule.h
+++ b/Source/Graphics/D12/D12GraphicsModule.h
@@ -71,9 +71,9 @@ struct D12RootSubParamter
 
 enum D12RootParamterType
 {
-	kD12RootParamterTypeTableSRV,
-	kD12RootParamterTypeTableSamplers,
-	kD12RootParamterTypeConstantBuffer,
+	D12RootParamterTypeTableSRV,
+	D12RootParamterTypeTableSamplers,
+	D12RootParamterTypeConstantBuffer,
 };
 
 struct D12RootParamter
@@ -83,7 +83,7 @@ struct D12RootParamter
 
 	static D12RootParamter AsConstantBuffer(const char* name)
 	{
-		D12RootParamter parameter(kD12RootParamterTypeConstantBuffer);
+		D12RootParamter parameter(D12RootParamterTypeConstantBuffer);
 		parameter.supParameters.push_back(D12RootSubParamter(name, (D3D12_DESCRIPTOR_RANGE_TYPE)-1));
 		return parameter;
 	}
@@ -167,24 +167,24 @@ struct D12SwapChain : public ISwapChain
 {
 	D12SwapChain(const IView* view) :
 		ISwapChain(view),
-		backBufferIndex(0),
-		backBuffers(nullptr),
+		bacBufferIndex(0),
+		bacBuffers(nullptr),
 		IDXGISwapChain3(nullptr)
 	{
 	}
 
 	inline IDXGISwapChain3* GetIDXGISwapChain3() const { return IDXGISwapChain3; }
-	inline D12Texture* GetBackBuffer() const { return backBuffers[backBufferIndex]; }
+	inline D12Texture* GetBacBuffer() const { return bacBuffers[bacBufferIndex]; }
 
-	D12Texture** backBuffers;
-	uint32_t backBufferIndex;
+	D12Texture** bacBuffers;
+	uint32_t bacBufferIndex;
 	uint32_t width;
 	uint32_t height;
 
 	IDXGISwapChain3* IDXGISwapChain3;
 };
 
-struct D12BlitCopy : public DrawSimple
+struct D12BlitCopy : public DrawDesc
 {
 	D12RenderPass* renderPass;
 	D12Filter* filter;
@@ -200,33 +200,33 @@ public:
 	virtual void SetupExecuteOrder(ModuleManager* moduleManager) override;
 	virtual const char* GetName() { return "D12GraphicsModule"; }
 
-	virtual const ITexture* RecordCreateITexture(const ExecutionContext& context, uint32_t width, uint32_t height) override;
+	virtual const ITexture* RecCreateITexture(const ExecutionContext& context, uint32_t width, uint32_t height) override;
 
-	virtual const IFilter* RecordCreateIFilter(const ExecutionContext& context, const FilterOptions& options) override;
+	virtual const IFilter* RecCreateIFilter(const ExecutionContext& context, const FilterOptions& options) override;
 
-	virtual const IRenderPass* RecordCreateIRenderPass(const ExecutionContext& context) override;
-	virtual void RecordSetColorAttachment(const ExecutionContext& context, const IRenderPass* target, uint32_t index, const ColorAttachment& attachment) override;
-	virtual void RecordSetDepthAttachment(const ExecutionContext& context, const IRenderPass* target, const DepthAttachment& attachment) override;
-	virtual void RecordSetViewport(const ExecutionContext& context, const IRenderPass* target, const Viewport& viewport) override;
-	virtual void RecordSetRenderPass(const ExecutionContext& context, const IRenderPass* target) override;
+	virtual const IRenderPass* RecCreateIRenderPass(const ExecutionContext& context) override;
+	virtual void RecSetColorAttachment(const ExecutionContext& context, const IRenderPass* target, uint32_t index, const ColorAttachment& attachment) override;
+	virtual void RecSetDepthAttachment(const ExecutionContext& context, const IRenderPass* target, const DepthAttachment& attachment) override;
+	virtual void RecSetViewport(const ExecutionContext& context, const IRenderPass* target, const Viewport& viewport) override;
+	virtual void RecSetRenderPass(const ExecutionContext& context, const IRenderPass* target) override;
 
-	virtual const IShaderPipeline* RecordCreateIShaderPipeline(const ExecutionContext& context, const ShaderPipelineDesc* desc) override;
-	virtual const IShaderArguments* RecordCreateIShaderArguments(const ExecutionContext& context, const IShaderPipeline* pipeline) override;
-	virtual void RecordSetTexture(const ExecutionContext& context, const IShaderArguments* properties, const char* name, const ITexture* texture) override;
-	virtual void RecordSetFilter(const ExecutionContext& context, const IShaderArguments* properties, const char* name, const IFilter* filter) override;
-	virtual void RecordSetBuffer(const ExecutionContext& context, const IShaderArguments* properties, const char* name, const IBuffer* buffer) override;
+	virtual const IShaderPipeline* RecCreateIShaderPipeline(const ExecutionContext& context, const ShaderPipelineDesc* desc) override;
+	virtual const IShaderArguments* RecCreateIShaderArguments(const ExecutionContext& context, const IShaderPipeline* pipeline) override;
+	virtual void RecSetTexture(const ExecutionContext& context, const IShaderArguments* properties, const char* name, const ITexture* texture) override;
+	virtual void RecSetFilter(const ExecutionContext& context, const IShaderArguments* properties, const char* name, const IFilter* filter) override;
+	virtual void RecSetBuffer(const ExecutionContext& context, const IShaderArguments* properties, const char* name, const IBuffer* buffer) override;
 
-	virtual const IBuffer* RecordCreateIBuffer(const ExecutionContext& context, size_t size) override;
-	virtual void RecordUpdateBuffer(const ExecutionContext& context, const IBuffer* target, void* data, size_t size) override;
+	virtual const IBuffer* RecCreateIBuffer(const ExecutionContext& context, size_t size) override;
+	virtual void RecUpdateBuffer(const ExecutionContext& context, const IBuffer* target, void* data, size_t size) override;
 
-	virtual const ISwapChain* RecordCreateISwapChain(const ExecutionContext& context, const IView* view) override;
-	virtual void RecordPresent(const ExecutionContext& context, const ISwapChain* swapchain, const ITexture* offscreen) override;
-	virtual void RecordFinalBlit(const ExecutionContext& context, const ISwapChain* swapchain, const ITexture* offscreen) override;
+	virtual const ISwapChain* RecCreateISwapChain(const ExecutionContext& context, const IView* view) override;
+	virtual void RecPresent(const ExecutionContext& context, const ISwapChain* swapchain, const ITexture* offscreen) override;
+	virtual void RecFinalBlit(const ExecutionContext& context, const ISwapChain* swapchain, const ITexture* offscreen) override;
 
-	virtual void RecordPushDebug(const ExecutionContext& context, const char* name) override;
-	virtual void RecordPopDebug(const ExecutionContext& context) override;
+	virtual void RecPushDebug(const ExecutionContext& context, const char* name) override;
+	virtual void RecPopDebug(const ExecutionContext& context) override;
 
-	virtual void RecordBindDrawSimple(const ExecutionContext& context, const DrawSimple& target) override;
+	virtual void RecDraw(const ExecutionContext& context, const DrawDesc& target) override;
 
 protected:
 	virtual bool ExecuteCommand(const ExecutionContext& context, IOStream& stream, uint32_t commandCode) override;
@@ -259,7 +259,7 @@ private:
 	inline void SetViewport(const ExecutionContext& context, D12RenderPass* target, const Viewport& viewport);
 	inline void SetRenderPass(const ExecutionContext& context, const D12RenderPass* target);
 	inline void UpdateBuffer(D12Buffer* target, uint32_t targetOffset, Range<uint8_t> data);
-	inline void BindDrawSimple(const ExecutionContext& context, const DrawSimple& target);
+	inline void Draw(const ExecutionContext& context, const DrawDesc& target);
 	inline void SetName(ID3D12Object* object, const wchar_t* format, ...);
 
 private:
diff --git a/Source/Graphics/D12/D12GraphicsPlannerModule.cpp b/Source/Graphics/D12/D12GraphicsPlannerModule.cpp
index ba8f26a..58e4d8b 100644
--- a/Source/Graphics/D12/D12GraphicsPlannerModule.cpp
+++ b/Source/Graphics/D12/D12GraphicsPlannerModule.cpp
@@ -3,8 +3,9 @@
 #include <Graphics\D12\D12GraphicsExecuterModule.h>
 #include <Graphics\D12\D12Heap.h>
 
-D12GraphicsPlannerModule::D12GraphicsPlannerModule(ID3D12Device* device) :
-	device(device)
+D12GraphicsPlannerModule::D12GraphicsPlannerModule(ID3D12Device* device) 
+	: device(device)
+	, drawOptimizers(4)
 {
 	directQueue = new D12CmdQueue(device, D3D12_COMMAND_LIST_TYPE_DIRECT);
 	directAllocatorPool = new D12CmdAllocatorPool(device, D3D12_COMMAND_LIST_TYPE_DIRECT);
@@ -39,10 +40,10 @@ uint64_t D12GraphicsPlannerModule::GetCompletedBufferIndex()
 	return executer->Get_completedBufferIndex();
 }
 
-size_t D12GraphicsPlannerModule::GetExecutionkSize() { return recordedCmdBuffers.size(); }
+size_t D12GraphicsPlannerModule::GetExecutionSize() { return recordedCmdBuffers.size(); }
 size_t D12GraphicsPlannerModule::GetSplitExecutionSize(size_t currentSize) 
 { 
-	if (currentSize == GetExecutionkSize())
+	if (currentSize == GetExecutionSize())
 		return recordedCmdBuffers.size() % 4 + recordedCmdBuffers.size() / 4;
 	else
 		return recordedCmdBuffers.size() / 4;
@@ -50,11 +51,12 @@ size_t D12GraphicsPlannerModule::GetSplitExecutionSize(size_t currentSize)
 
 void D12GraphicsPlannerModule::Execute(const ExecutionContext& context)
 {
-	auto allocatorPool = directAllocatorPool->TryPull(directQueue->GetCompletedBufferIndex());
-	uint64_t lastBufferIndex = 0;
+	/*auto allocatorPool = directAllocatorPool->TryPull(directQueue->GetCompletedBufferIndex());
+	D12CmdBuffer* buffer = nullptr;
+
 	for (uint32_t j = context.offset; j < context.offset + context.size; j++)
 	{
-		auto buffer = recordedCmdBuffers[j];
+		buffer = recordedCmdBuffers[j];
 		auto& stream = buffer->stream;
 		directQueue->Reset(buffer, allocatorPool);
 		for (int i = 0; i < buffer->commandCount; i++)
@@ -64,37 +66,75 @@ void D12GraphicsPlannerModule::Execute(const ExecutionContext& context)
 			ASSERT(ExecuteCommand(context, buffer, commandCode));
 		}
 		directQueue->Close(buffer);
-		executer->RecordCmdBuffer(context, buffer);
-		lastBufferIndex = buffer->index;
+		executer->RecCmdBuffer(context, buffer);
+	}
+
+	directAllocatorPool->Push(buffer->index, allocatorPool);*/
+
+	auto allocatorPool = directAllocatorPool->TryPull(directQueue->GetCompletedBufferIndex());
+	D12CmdBuffer* buffer = nullptr;
+	D12CmdBuffer* mainBuffer = recordedCmdBuffers[context.offset];
+
+	directQueue->Reset(mainBuffer, allocatorPool);
+	
+	for (uint32_t j = context.offset; j < context.offset + context.size; j++)
+	{
+		buffer = recordedCmdBuffers[j];
+		auto& stream = buffer->stream;
+		stream.Reset();
+
+		auto cachedCmdList = buffer->commandList;
+		buffer->commandList = mainBuffer->commandList;
+		for (int i = 0; i < buffer->commandCount; i++)
+		{
+			//uint32_t commandCode;
+			//stream.Read(commandCode);
+			auto& commandCode = stream.FastRead<uint32_t>();
+			ASSERT(ExecuteCommand(context, buffer, commandCode));
+		}
+		buffer->commandList = cachedCmdList;
+
+		
+
+		if (buffer->swapChain)
+			executer->RecCmdBuffer(context, buffer);
 	}
-	directAllocatorPool->Push(lastBufferIndex, allocatorPool);
+
+	directQueue->Close(mainBuffer);
+
+	executer->RecCmdBuffer(context, mainBuffer);
+
+	directAllocatorPool->Push(buffer->index, allocatorPool);
+
+	auto& drawOptimizer = drawOptimizers[context.workerIndex];
+	drawOptimizer.Clear();
 }
 
 DECLARE_COMMAND_CODE(PushDebug);
-void D12GraphicsPlannerModule::RecordPushDebug(const char* name)
+void D12GraphicsPlannerModule::RecPushDebug(const char* name)
 {
 	auto buffer = ContinueRecording();
 	auto& stream = buffer->stream;
-	stream.Write(kCommandCodePushDebug);
+	stream.Write(CommandCodePushDebug);
 	stream.Write(name);
 	buffer->commandCount++;
 }
 
 DECLARE_COMMAND_CODE(PopDebug);
-void D12GraphicsPlannerModule::RecordPopDebug()
+void D12GraphicsPlannerModule::RecPopDebug()
 {
 	auto buffer = ContinueRecording();
 	auto& stream = buffer->stream;
-	stream.Write(kCommandCodePopDebug);
+	stream.Write(CommandCodePopDebug);
 	buffer->commandCount++;
 }
 
 DECLARE_COMMAND_CODE(SetTextureState);
-void D12GraphicsPlannerModule::RecordSetTextureState(const D12Texture* target, D3D12_RESOURCE_STATES currentState, D3D12_RESOURCE_STATES nextState)
+void D12GraphicsPlannerModule::RecSetTextureState(const D12Texture* target, D3D12_RESOURCE_STATES currentState, D3D12_RESOURCE_STATES nextState)
 {
 	auto buffer = ContinueRecording();
 	auto& stream = buffer->stream;
-	stream.Write(kCommandCodeSetTextureState);
+	stream.Write(CommandCodeSetTextureState);
 	stream.Write(target);
 	stream.Write(currentState);
 	stream.Write(nextState);
@@ -102,11 +142,11 @@ void D12GraphicsPlannerModule::RecordSetTextureState(const D12Texture* target, D
 }
 
 DECLARE_COMMAND_CODE(SetBufferState);
-void D12GraphicsPlannerModule::RecordSetBufferState(const D12Buffer* target, D3D12_RESOURCE_STATES currentState, D3D12_RESOURCE_STATES nextState)
+void D12GraphicsPlannerModule::RecSetBufferState(const D12Buffer* target, D3D12_RESOURCE_STATES currentState, D3D12_RESOURCE_STATES nextState)
 {
 	auto buffer = ContinueRecording();
 	auto& stream = buffer->stream;
-	stream.Write(kCommandCodeSetBufferState);
+	stream.Write(CommandCodeSetBufferState);
 	stream.Write(target);
 	stream.Write(currentState);
 	stream.Write(nextState);
@@ -114,28 +154,30 @@ void D12GraphicsPlannerModule::RecordSetBufferState(const D12Buffer* target, D3D
 }
 
 DECLARE_COMMAND_CODE(SetRenderPass);
-void D12GraphicsPlannerModule::RecordSetRenderPass(const D12RenderPass* target)
+void D12GraphicsPlannerModule::RecSetRenderPass(const D12RenderPass* target, bool ignoreLoadActions)
 {
 	auto buffer = ContinueRecording();
 	auto& stream = buffer->stream;
-	stream.Write(kCommandCodeSetRenderPass);
-	stream.Write(*target); // We need copy here, because renderpass lives on cpu
+	stream.Write(CommandCodeSetRenderPass);
+	recordingOptimizer.MarSetRenderPass((D12RenderPass*)target);
+	stream.Write((void*)target, sizeof(D12RenderPass)); // We need copy here, because renderpass lives on cpu
+	stream.Write(ignoreLoadActions);
 	buffer->commandCount++;
 }
 
 DECLARE_COMMAND_CODE(UpdateBuffer);
-void D12GraphicsPlannerModule::RecordUpdateBuffer(const D12Buffer* target, uint32_t targetOffset, Range<uint8_t> data)
+void D12GraphicsPlannerModule::RecUpdateBuffer(const D12Buffer* target, uint32_t targetOffset, Range<uint8_t> data)
 { 
 	auto buffer = ContinueRecording();
 	auto& stream = buffer->stream;
-	stream.Write(kCommandCodeUpdateBuffer);
+	stream.Write(CommandCodeUpdateBuffer);
 	stream.Write(target);
 	stream.Write(targetOffset);
 	stream.Write(data);
 	buffer->commandCount++;
 }
 
-void D12GraphicsPlannerModule::RecordPresent(const D12SwapChain* swapchain)
+void D12GraphicsPlannerModule::RecPresent(const D12SwapChain* swapchain)
 {
 	SplitRecording();
 	auto buffer = ContinueRecording();
@@ -143,12 +185,20 @@ void D12GraphicsPlannerModule::RecordPresent(const D12SwapChain* swapchain)
 	buffer->swapChain = swapchain->GetIDXGISwapChain3();
 }
 
-DECLARE_COMMAND_CODE(DrawSimple);
-void D12GraphicsPlannerModule::RecordDrawSimple(const DrawSimple& target)
+DECLARE_COMMAND_CODE(Draw);
+void D12GraphicsPlannerModule::RecDraw(const DrawDesc& target)
 {
+	// Lets try to split big command lists this way we can distribut work accross workers
+	if (recordingOptimizer.ShouldSplitRecording())
+	{
+		SplitRecording();
+		RecSetHeap((const D12Heap**) recordingOptimizer.lastHeaps);
+		RecSetRenderPass(recordingOptimizer.lastRenderPass, true);
+	}
+
 	auto buffer = ContinueRecording();
 	auto& stream = buffer->stream;
-	stream.Write(kCommandCodeDrawSimple);
+	stream.Write(CommandCodeDraw);
 	stream.Write(target);
 
 	auto& rootParameters = ((D12ShaderPipeline*) target.pipeline)->rootParameters;
@@ -160,13 +210,13 @@ void D12GraphicsPlannerModule::RecordDrawSimple(const DrawSimple& target)
 
 		switch (rootParameter.type)
 		{
-		case kD12RootParamterTypeTableSRV:
-		case kD12RootParamterTypeTableSamplers:
+		case D12RootParamterTypeTableSRV:
+		case D12RootParamterTypeTableSamplers:
 		{
 			stream.Write(rootArgument.memory);
 			break;
 		}
-		case kD12RootParamterTypeConstantBuffer:
+		case D12RootParamterTypeConstantBuffer:
 		{
 			stream.Write(rootArgument.subData);
 			break;
@@ -175,19 +225,21 @@ void D12GraphicsPlannerModule::RecordDrawSimple(const DrawSimple& target)
 	}
 
 	buffer->commandCount++;
+	recordingOptimizer.MarDraw();
 }
 
 DECLARE_COMMAND_CODE(SetHeap);
-void D12GraphicsPlannerModule::RecordSetHeap(const D12Heap* heap)
+void D12GraphicsPlannerModule::RecSetHeap(const D12Heap** heap)
 {
 	auto buffer = ContinueRecording();
 	auto& stream = buffer->stream;
-	stream.Write(kCommandCodeSetHeap);
-	stream.Write(heap);
+	stream.Write(CommandCodeSetHeap);
+	recordingOptimizer.MarSetHeap((D12Heap**) heap);
+	stream.Write(heap, sizeof(D12Heap*) * D12HeapTypeCount);
 	buffer->commandCount++;
 }
 
-void D12GraphicsPlannerModule::RecordRequestSplit()
+void D12GraphicsPlannerModule::RecRequestSplit()
 {
 	SplitRecording();
 }
@@ -225,7 +277,7 @@ bool D12GraphicsPlannerModule::ExecuteCommand(const ExecutionContext& context, D
 		commandList->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(target->resource, currentState, nextState));
 		DESERIALIZE_METHOD_END;
 
-		DESERIALIZE_METHOD_ARG1_START(SetRenderPass, D12RenderPass, target);
+		DESERIALIZE_METHOD_ARG2_START(SetRenderPass, D12RenderPass, target, bool, ignoreLoadActions);
 		auto count = target.colorDescriptorsCount;
 		ASSERT(count != 0);
 		if (target.depth.texture != nullptr)
@@ -237,14 +289,17 @@ bool D12GraphicsPlannerModule::ExecuteCommand(const ExecutionContext& context, D
 
 		// TODO: make it dynamic maybe, need to find out if staticlly assigning heaps is costly and having it assigned
 		ID3D12DescriptorHeap* heaps[] = {
-			buffer->heaps[kD12HeapTypeSRVs]->Get_heap(),
-			buffer->heaps[kD12HeapTypeSamplers]->Get_heap() };
+			buffer->heaps[D12HeapTypeSRVs]->Get_heap(),
+			buffer->heaps[D12HeapTypeSamplers]->Get_heap() };
 		commandList->SetDescriptorHeaps(2, heaps);
 
+		if (ignoreLoadActions)
+			return true;
+
 		for (int i = 0; i < count; i++)
 		{
 			auto& color = target.colors[i];
-			if (color.loadAction == kLoadActionClear)
+			if (color.loadAction == LoadActionClear)
 			{
 				const float clearColor[] = { color.clearColor.r, color.clearColor.g, color.clearColor.b, color.clearColor.a };
 				commandList->ClearRenderTargetView(target.colorDescriptors[i], clearColor, 0, nullptr);
@@ -252,7 +307,7 @@ bool D12GraphicsPlannerModule::ExecuteCommand(const ExecutionContext& context, D
 		}
 
 		auto& depth = target.depth;
-		if (depth.texture != nullptr && depth.loadAction == kLoadActionClear)
+		if (depth.texture != nullptr && depth.loadAction == LoadActionClear)
 		{
 			commandList->ClearDepthStencilView(target.depthDescriptor, D3D12_CLEAR_FLAG_DEPTH, target.depth.clearDepth, 0, 0, nullptr);
 		}
@@ -266,10 +321,18 @@ bool D12GraphicsPlannerModule::ExecuteCommand(const ExecutionContext& context, D
 		target->resource->Unmap(0, nullptr);
 		DESERIALIZE_METHOD_END;
 
-		DESERIALIZE_METHOD_ARG1_START(DrawSimple, DrawSimple, target);
+		DESERIALIZE_METHOD_ARG1_START(Draw, DrawDesc, target);
+		auto& drawOptimizer = drawOptimizers[context.workerIndex];
+
+		// If we used same pipeline lets skip
 		auto pipeline = (const D12ShaderPipeline*) target.pipeline;
-		commandList->SetPipelineState(pipeline->pipelineState);
-		commandList->SetGraphicsRootSignature(pipeline->rootSignature);
+		if (drawOptimizer.lastPipeline != pipeline)
+		{
+			commandList->SetPipelineState(pipeline->pipelineState);
+			commandList->SetGraphicsRootSignature(pipeline->rootSignature);
+			drawOptimizer.lastPipeline = pipeline;
+		}
+		
 		auto& rootParameters = ((D12ShaderPipeline*) target.pipeline)->rootParameters;
 		auto& rootArguments = ((D12ShaderArguments*) target.properties)->rootArguments;
 		for (size_t i = 0; i < rootParameters.size(); i++)
@@ -279,40 +342,67 @@ bool D12GraphicsPlannerModule::ExecuteCommand(const ExecutionContext& context, D
 			
 			switch (rootParameter.type)
 			{
-			case kD12RootParamterTypeTableSRV:
+			case D12RootParamterTypeTableSRV:
 			{
-				ASSERT(buffer->heaps[kD12HeapTypeSRVs] != nullptr);
-				D12HeapMemory value; stream.Read<D12HeapMemory>(value);
-				commandList->SetGraphicsRootDescriptorTable((UINT) i, buffer->heaps[kD12HeapTypeSRVs]->GetGpuHandle(value));
+				ASSERT(buffer->heaps[D12HeapTypeSRVs] != nullptr);
+				auto& value = stream.FastRead<D12HeapMemory>();
+				auto handle = buffer->heaps[D12HeapTypeSRVs]->GetGpuHandle(value);
+				
+				if (handle.ptr != drawOptimizer.rootArguments[i])
+				{
+					commandList->SetGraphicsRootDescriptorTable((UINT) i, handle);
+					drawOptimizer.rootArguments[i] = handle.ptr;
+				}
+				
 				break;
 			}
-			case kD12RootParamterTypeTableSamplers:
+			case D12RootParamterTypeTableSamplers:
 			{
-				ASSERT(buffer->heaps[kD12HeapTypeSamplers] != nullptr);
-				D12HeapMemory value; stream.Read<D12HeapMemory>(value);
-				commandList->SetGraphicsRootDescriptorTable((UINT) i, buffer->heaps[kD12HeapTypeSamplers]->GetGpuHandle(value));
+				ASSERT(buffer->heaps[D12HeapTypeSamplers] != nullptr);
+				auto& value = stream.FastRead<D12HeapMemory>();
+				auto handle = buffer->heaps[D12HeapTypeSamplers]->GetGpuHandle(value);
+
+				if (handle.ptr != drawOptimizer.rootArguments[i])
+				{
+					commandList->SetGraphicsRootDescriptorTable((UINT) i, handle);
+					drawOptimizer.rootArguments[i] = handle.ptr;
+				}
+				
 				break;
 			}
-			case kD12RootParamterTypeConstantBuffer:
+			case D12RootParamterTypeConstantBuffer:
 			{
-				D3D12_GPU_VIRTUAL_ADDRESS value; stream.Read<D3D12_GPU_VIRTUAL_ADDRESS>(value);
-				commandList->SetGraphicsRootConstantBufferView((UINT) i, value);
+				auto& value = stream.FastRead<D3D12_GPU_VIRTUAL_ADDRESS>();
+
+				if (value != drawOptimizer.rootArguments[i])
+				{
+					commandList->SetGraphicsRootConstantBufferView((UINT) i, value);
+					drawOptimizer.rootArguments[i] = value;
+				}
+				
 				break;
 			}
 			}
 		}
-		auto vertexBufferView = pipeline->vertexBuffer;
-		auto vertexBuffer = (const D12Buffer*) target.vertexBuffer;
-		vertexBufferView.BufferLocation = vertexBuffer->resource->GetGPUVirtualAddress();
-		vertexBufferView.SizeInBytes = (UINT) vertexBuffer->data.size;
-		ASSERT(vertexBufferView.SizeInBytes % vertexBufferView.StrideInBytes == 0);
-		commandList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
-		commandList->IASetVertexBuffers(0, 1, &vertexBufferView);
+
+		// If we used same pipeline and vertex buffer lets skip
+		if (drawOptimizer.lastPipeline != pipeline || drawOptimizer.lastVertexBuffer != target.vertexBuffer)
+		{
+			auto vertexBufferView = pipeline->vertexBuffer;
+			auto vertexBuffer = (const D12Buffer*) target.vertexBuffer;
+			vertexBufferView.BufferLocation = vertexBuffer->resource->GetGPUVirtualAddress();
+			vertexBufferView.SizeInBytes = (UINT) vertexBuffer->data.size;
+			ASSERT(vertexBufferView.SizeInBytes % vertexBufferView.StrideInBytes == 0);
+			commandList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
+			commandList->IASetVertexBuffers(0, 1, &vertexBufferView);
+			drawOptimizer.lastVertexBuffer = target.vertexBuffer;
+		}
+
 		commandList->DrawInstanced(target.size, 1, target.offset, 0);
 		DESERIALIZE_METHOD_END;
 
-		DESERIALIZE_METHOD_ARG1_START(SetHeap, D12Heap*, heap);
-		buffer->heaps[heap->Get_type()] = heap;
+		DESERIALIZE_METHOD_START(SetHeap);
+		stream.Read(buffer->heaps, sizeof(D12Heap*) * D12HeapTypeCount);
 		DESERIALIZE_METHOD_END;
 	}
 	return false;
diff --git a/Source/Graphics/D12/D12GraphicsPlannerModule.h b/Source/Graphics/D12/D12GraphicsPlannerModule.h
index 08a2971..a907b26 100644
--- a/Source/Graphics/D12/D12GraphicsPlannerModule.h
+++ b/Source/Graphics/D12/D12GraphicsPlannerModule.h
@@ -21,20 +21,20 @@ public:
 	D12GraphicsPlannerModule(ID3D12Device* device);
 	virtual void SetupExecuteOrder(ModuleManager* moduleManager) override;
 	virtual void Execute(const ExecutionContext& context) override;
-	virtual size_t GetExecutionkSize() override;
+	virtual size_t GetExecutionSize() override;
 	virtual size_t GetSplitExecutionSize(size_t currentSize) override;
 	virtual const char* GetName() { return "D12GraphicsPlannerModule"; }
 
-	void RecordRequestSplit();
-	void RecordPushDebug(const char* name);
-	void RecordPopDebug();
-	void RecordSetTextureState(const D12Texture* target, D3D12_RESOURCE_STATES currentState, D3D12_RESOURCE_STATES nextState);
-	void RecordSetBufferState(const D12Buffer* target, D3D12_RESOURCE_STATES currentState, D3D12_RESOURCE_STATES nextState);
-	void RecordSetRenderPass(const D12RenderPass* target);
-	void RecordUpdateBuffer(const D12Buffer* target, uint32_t targetOffset, Range<uint8_t> data);
-	void RecordPresent(const D12SwapChain* swapchain);
-	void RecordDrawSimple(const DrawSimple& target);
-	void RecordSetHeap(const D12Heap* heap);
+	void RecRequestSplit();
+	void RecPushDebug(const char* name);
+	void RecPopDebug();
+	void RecSetTextureState(const D12Texture* target, D3D12_RESOURCE_STATES currentState, D3D12_RESOURCE_STATES nextState);
+	void RecSetBufferState(const D12Buffer* target, D3D12_RESOURCE_STATES currentState, D3D12_RESOURCE_STATES nextState);
+	void RecSetRenderPass(const D12RenderPass* target, bool ignoreLoadActions = false);
+	void RecUpdateBuffer(const D12Buffer* target, uint32_t targetOffset, Range<uint8_t> data);
+	void RecPresent(const D12SwapChain* swapchain);
+	void RecDraw(const DrawDesc& target);
+	void RecSetHeap(const D12Heap** heap);
 
 	void Reset();
 	ID3D12CommandQueue* GetDirectQueue();
@@ -51,6 +51,34 @@ private:
 	D12CmdAllocatorPool* directAllocatorPool;
 	List<D12CmdBuffer*> recordedCmdBuffers;
 
+	struct RecingOptimizer
+	{
+		inline void MarSetRenderPass(D12RenderPass* renderPass) { lastRenderPass = renderPass; drawCount = 0; }
+		inline void MarDraw() { drawCount++; }
+		inline void MarSetHeap(D12Heap** heaps) { memcpy((void*)lastHeaps, (void*)heaps, sizeof(D12Heap*) * D12HeapTypeCount); }
+		inline bool ShouldSplitRecording() { return drawCount == 500; }
+		
+		D12RenderPass* lastRenderPass;
+		D12Heap* lastHeaps[D12HeapTypeCount];
+		size_t drawCount;
+	};
+	RecingOptimizer recordingOptimizer;
+
+	struct DrawOptimizer
+	{
+		DrawOptimizer() { Clear(); }
+		void Clear()
+		{
+			lastPipeline = nullptr; 
+			lastVertexBuffer = nullptr; memset(rootArguments, 0, sizeof(UINT64) * 30);
+		}
+		const IShaderPipeline* lastPipeline;
+		const IBuffer* lastVertexBuffer;
+		UINT64 rootArguments[30];
+
+	};
+	List<DrawOptimizer> drawOptimizers;
+
 	D12GraphicsExecuterModule* executer;
 	ID3D12CommandAllocator* commandAllocator;
 	ID3D12Device* device;
diff --git a/Source/Graphics/D12/D12Heap.cpp b/Source/Graphics/D12/D12Heap.cpp
index 625641d..790d737 100644
--- a/Source/Graphics/D12/D12Heap.cpp
+++ b/Source/Graphics/D12/D12Heap.cpp
@@ -51,25 +51,25 @@ void D12Heap::Free(D12HeapMemory& memory)
 	while (current != end)
 	{
 		auto next = current->next;
-		auto mergableWithBlockAbove = current->pointer + current->size == memory.pointer;
-		auto mergableWithBlockBelow = next->pointer == memory.pointer + memory.size;
+		auto mergableWithBlocAbove = current->pointer + current->size == memory.pointer;
+		auto mergableWithBlocBelow = next->pointer == memory.pointer + memory.size;
 		
 		// 1) Fred memory can be merged with block above
-		if (mergableWithBlockAbove && !mergableWithBlockBelow)
+		if (mergableWithBlocAbove && !mergableWithBlocBelow)
 		{
 			current->size += memory.size;
 			return;
 		}
 
 		// 2) Fred memory can be merged with block below
-		if (!mergableWithBlockAbove && mergableWithBlockBelow)
+		if (!mergableWithBlocAbove && mergableWithBlocBelow)
 		{
 			next->pointer -= memory.size;
 			return;
 		}
 
 		// 3) Fred memory can be merged with blocks above and below
-		if (mergableWithBlockAbove && mergableWithBlockBelow)
+		if (mergableWithBlocAbove && mergableWithBlocBelow)
 		{
 			current->size += memory.size + next->size;
 			Connect(current, next->next);
@@ -100,27 +100,27 @@ void D12Heap::Grow(size_t capacity)
 		srvHeapDesc.NumDescriptors = (UINT)capacity;
 		switch (type)
 		{
-		case kD12HeapTypeSRVs:
+		case D12HeapTypeSRVs:
 			srvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
 			srvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
 			stride = device->GetDescriptorHandleIncrementSize(srvHeapDesc.Type);
 			break;
-		case kD12HeapTypeSamplers:
+		case D12HeapTypeSamplers:
 			srvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER;
 			srvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
 			stride = device->GetDescriptorHandleIncrementSize(srvHeapDesc.Type);
 			break;
-		case kD12HeapTypeRTVs:
+		case D12HeapTypeRTVs:
 			srvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;
 			srvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
 			stride = device->GetDescriptorHandleIncrementSize(srvHeapDesc.Type);
 			break;
-		case kD12HeapTypeSRVsCPU:
+		case D12HeapTypeSRVsCPU:
 			srvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
 			srvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
 			stride = device->GetDescriptorHandleIncrementSize(srvHeapDesc.Type);
 			break;
-		case kD12HeapTypeSamplersCPU:
+		case D12HeapTypeSamplersCPU:
 			srvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER;
 			srvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
 			stride = device->GetDescriptorHandleIncrementSize(srvHeapDesc.Type);
diff --git a/Source/Graphics/D12/D12Heap.h b/Source/Graphics/D12/D12Heap.h
index 922c788..82ecd58 100644
--- a/Source/Graphics/D12/D12Heap.h
+++ b/Source/Graphics/D12/D12Heap.h
@@ -5,12 +5,12 @@
 
 enum D12HeapType
 {
-	kD12HeapTypeSRVs,
-	kD12HeapTypeSamplers,
-	kD12HeapTypeRTVs,
-	kD12HeapTypeSRVsCPU,
-	kD12HeapTypeSamplersCPU,
-	kD12HeapTypeCount,
+	D12HeapTypeSRVs,
+	D12HeapTypeSamplers,
+	D12HeapTypeRTVs,
+	D12HeapTypeSRVsCPU,
+	D12HeapTypeSamplersCPU,
+	D12HeapTypeCount,
 };
 
 struct D12HeapMemory
diff --git a/Source/Graphics/IBuffer.h b/Source/Graphics/IBuffer.h
index 25692c5..3758362 100644
--- a/Source/Graphics/IBuffer.h
+++ b/Source/Graphics/IBuffer.h
@@ -4,15 +4,15 @@
 
 enum BufferUsageFlags
 {
-	kBufferUsageFlagNone = 0,
-	kBufferUsageFlagsShader = 1 << 0,
+	BufferUsageFlagNone = 0,
+	BufferUsageFlagsShader = 1 << 0,
 };
 
 struct IBuffer
 {
 	IBuffer(size_t size) : 
 		data(new uint8_t[size], size),
-		usage(kBufferUsageFlagsShader)
+		usage(BufferUsageFlagsShader)
 	{}
 
 	inline size_t GetSize() const { return data.size; }
diff --git a/Source/Graphics/IGraphicsModule.h b/Source/Graphics/IGraphicsModule.h
index a1ce734..47d8efe 100644
--- a/Source/Graphics/IGraphicsModule.h
+++ b/Source/Graphics/IGraphicsModule.h
@@ -11,7 +11,7 @@
 
 struct IView;
 
-struct DrawSimple
+struct DrawDesc
 {
 	const IShaderPipeline* pipeline;
 	const IShaderArguments* properties;
@@ -25,31 +25,31 @@ class IGraphicsModule : public CmdModule
 public:
 	IGraphicsModule(uint32_t bufferCount, uint32_t workersCount);
 
-	virtual const ITexture* RecordCreateITexture(const ExecutionContext& context, uint32_t width, uint32_t height) = 0;
+	virtual const ITexture* RecCreateITexture(const ExecutionContext& context, uint32_t width, uint32_t height) = 0;
 
-	virtual const IFilter* RecordCreateIFilter(const ExecutionContext& context, const FilterOptions& options) = 0;
+	virtual const IFilter* RecCreateIFilter(const ExecutionContext& context, const FilterOptions& options) = 0;
 
-	virtual const IRenderPass* RecordCreateIRenderPass(const ExecutionContext& context) = 0;
-	virtual void RecordSetColorAttachment(const ExecutionContext& context, const IRenderPass* target, uint32_t index, const ColorAttachment& attachment) = 0;
-	virtual void RecordSetDepthAttachment(const ExecutionContext& context, const IRenderPass* target, const DepthAttachment& attachment) = 0;
-	virtual void RecordSetViewport(const ExecutionContext& context, const IRenderPass* target, const Viewport& viewport) = 0;
-	virtual void RecordSetRenderPass(const ExecutionContext& context, const IRenderPass* target) = 0;
+	virtual const IRenderPass* RecCreateIRenderPass(const ExecutionContext& context) = 0;
+	virtual void RecSetColorAttachment(const ExecutionContext& context, const IRenderPass* target, uint32_t index, const ColorAttachment& attachment) = 0;
+	virtual void RecSetDepthAttachment(const ExecutionContext& context, const IRenderPass* target, const DepthAttachment& attachment) = 0;
+	virtual void RecSetViewport(const ExecutionContext& context, const IRenderPass* target, const Viewport& viewport) = 0;
+	virtual void RecSetRenderPass(const ExecutionContext& context, const IRenderPass* target) = 0;
 
-	virtual const IShaderPipeline* RecordCreateIShaderPipeline(const ExecutionContext& context, const ShaderPipelineDesc* desc) = 0;
-	virtual const IShaderArguments* RecordCreateIShaderArguments(const ExecutionContext& context, const IShaderPipeline* pipeline) = 0;
-	virtual void RecordSetTexture(const ExecutionContext& context, const IShaderArguments* properties, const char* name, const ITexture* texture) = 0;
-	virtual void RecordSetFilter(const ExecutionContext& context, const IShaderArguments* properties, const char* name, const IFilter* filter) = 0;
-	virtual void RecordSetBuffer(const ExecutionContext& context, const IShaderArguments* properties, const char* name, const IBuffer* buffer) = 0;
+	virtual const IShaderPipeline* RecCreateIShaderPipeline(const ExecutionContext& context, const ShaderPipelineDesc* desc) = 0;
+	virtual const IShaderArguments* RecCreateIShaderArguments(const ExecutionContext& context, const IShaderPipeline* pipeline) = 0;
+	virtual void RecSetTexture(const ExecutionContext& context, const IShaderArguments* properties, const char* name, const ITexture* texture) = 0;
+	virtual void RecSetFilter(const ExecutionContext& context, const IShaderArguments* properties, const char* name, const IFilter* filter) = 0;
+	virtual void RecSetBuffer(const ExecutionContext& context, const IShaderArguments* properties, const char* name, const IBuffer* buffer) = 0;
 
-	virtual const IBuffer* RecordCreateIBuffer(const ExecutionContext& context, size_t size) = 0;
-	virtual void RecordUpdateBuffer(const ExecutionContext& context, const IBuffer* target, void* data, size_t size) = 0;
+	virtual const IBuffer* RecCreateIBuffer(const ExecutionContext& context, size_t size) = 0;
+	virtual void RecUpdateBuffer(const ExecutionContext& context, const IBuffer* target, void* data, size_t size) = 0;
 
-	virtual const ISwapChain* RecordCreateISwapChain(const ExecutionContext& context, const IView* view) = 0;
-	virtual void RecordPresent(const ExecutionContext& context, const ISwapChain* swapchain, const ITexture* offscreen) = 0;
-	virtual void RecordFinalBlit(const ExecutionContext& context, const ISwapChain* swapchain, const ITexture* offscreen) = 0;
+	virtual const ISwapChain* RecCreateISwapChain(const ExecutionContext& context, const IView* view) = 0;
+	virtual void RecPresent(const ExecutionContext& context, const ISwapChain* swapchain, const ITexture* offscreen) = 0;
+	virtual void RecFinalBlit(const ExecutionContext& context, const ISwapChain* swapchain, const ITexture* offscreen) = 0;
 
-	virtual void RecordPushDebug(const ExecutionContext& context, const char* name) = 0;
-	virtual void RecordPopDebug(const ExecutionContext& context) = 0;
+	virtual void RecPushDebug(const ExecutionContext& context, const char* name) = 0;
+	virtual void RecPopDebug(const ExecutionContext& context) = 0;
 
-	virtual void RecordBindDrawSimple(const ExecutionContext& context, const DrawSimple& target) = 0;
+	virtual void RecDraw(const ExecutionContext& context, const DrawDesc& target) = 0;
 };
\ No newline at end of file
diff --git a/Source/Graphics/IRenderPass.h b/Source/Graphics/IRenderPass.h
index 0c50aeb..e266269 100644
--- a/Source/Graphics/IRenderPass.h
+++ b/Source/Graphics/IRenderPass.h
@@ -10,20 +10,20 @@
 
 enum StoreAction
 {
-	kStoreActionStore,
+	StoreActionStore,
 };
 
 enum LoadAction
 {
-	kLoadActionLoad,
-	kLoadActionClear,
-	kLoadActionDontCare,
+	LoadActionLoad,
+	LoadActionClear,
+	LoadActionDontCare,
 };
 
 struct ColorAttachment
 {
-	ColorAttachment() : ColorAttachment(nullptr, kStoreActionStore, kLoadActionLoad) {}
-	ColorAttachment(const ITexture* texture) : ColorAttachment(texture, kStoreActionStore, kLoadActionLoad) {}
+	ColorAttachment() : ColorAttachment(nullptr, StoreActionStore, LoadActionLoad) {}
+	ColorAttachment(const ITexture* texture) : ColorAttachment(texture, StoreActionStore, LoadActionLoad) {}
 	ColorAttachment(const ITexture* texture, StoreAction storeAction, LoadAction loadAction) :
 		texture(texture), storeAction(storeAction), loadAction(loadAction), clearColor(Colorf(0, 0.2f, 0.4f, 0))
 	{
@@ -41,7 +41,7 @@ struct DepthAttachment
 		texture(texture), storeAction(storeAction), loadAction(loadAction), clearDepth(0)
 	{
 	}
-	DepthAttachment() : DepthAttachment(nullptr, kStoreActionStore, kLoadActionLoad) {}
+	DepthAttachment() : DepthAttachment(nullptr, StoreActionStore, LoadActionLoad) {}
 
 	const ITexture* texture;
 	StoreAction storeAction;
diff --git a/Source/Graphics/ISwapChain.h b/Source/Graphics/ISwapChain.h
index 3693a68..8654c12 100644
--- a/Source/Graphics/ISwapChain.h
+++ b/Source/Graphics/ISwapChain.h
@@ -8,9 +8,9 @@ struct ISwapChain
 {
 	ISwapChain(const IView* view) :
 		view(view),
-		backBufferCount(2)
+		bacBufferCount(2)
 	{
 	}
 	const IView* view;
-	const uint32_t backBufferCount;
+	const uint32_t bacBufferCount;
 };
\ No newline at end of file
diff --git a/Source/Graphics/ITexture.h b/Source/Graphics/ITexture.h
index a9ac8b8..1acd725 100644
--- a/Source/Graphics/ITexture.h
+++ b/Source/Graphics/ITexture.h
@@ -17,9 +17,9 @@ struct IFilter
 
 enum TextureUsageFlags
 {
-	kTextureUsageFlagNone = 0,
-	kTextureUsageFlagRender = 1 << 0,
-	kTextureUsageFlagShader = 1 << 1,
+	TextureUsageFlagNone = 0,
+	TextureUsageFlagRender = 1 << 0,
+	TextureUsageFlagShader = 1 << 1,
 };
 
 IMPLEMENT_ENUM_FLAG(TextureUsageFlags);
@@ -30,7 +30,7 @@ struct ITexture
 	ITexture(uint32_t width, uint32_t height) : 
 		width(width), 
 		height(height), 
-		usage(kTextureUsageFlagRender | kTextureUsageFlagShader)
+		usage(TextureUsageFlagRender | TextureUsageFlagShader)
 	{
 	}
 	uint32_t width;
diff --git a/Source/Graphics/Shader.h b/Source/Graphics/Shader.h
index fcc7701..59d2bcb 100644
--- a/Source/Graphics/Shader.h
+++ b/Source/Graphics/Shader.h
@@ -7,10 +7,10 @@
 
 enum ShaderParameterType
 {
-	kShaderParameterTypeBuffer,
-	kShaderParameterTypeConstantBuffer,
-	kShaderParameterTypeTexture,
-	kShaderParameterTypeSampler,
+	ShaderParameterTypeBuffer,
+	ShaderParameterTypeConstantBuffer,
+	ShaderParameterTypeTexture,
+	ShaderParameterTypeSampler,
 };
 
 struct ShaderParameter
@@ -23,28 +23,28 @@ struct ShaderParameter
 
 enum ZWrite
 {
-	kZWriteOn,
+	ZWriteOn,
 };
 
 enum ZTest
 {
-	kZTestLEqual,
+	ZTestLEqual,
 };
 
 struct ShaderStates
 {
 	ShaderStates() : 
-		zWrite(kZWriteOn), 
-		zTest(kZTestLEqual) {}
+		zWrite(ZWriteOn), 
+		zTest(ZTestLEqual) {}
 	ZWrite zWrite;
 	ZTest zTest;
 };
 
 enum ShaderProgramType
 {
-	kShaderProgramTypeVertex,
-	kShaderProgramTypeFragment,
-	kShaderProgramTypeCount,
+	ShaderProgramTypeVertex,
+	ShaderProgramTypeFragment,
+	ShaderProgramTypeCount,
 };
 
 struct ShaderProgram
@@ -72,7 +72,7 @@ struct ShaderPipelineDesc
 {
 	List<ShaderParameter> parameters;
 	ShaderStates states;
-	ShaderProgram programs[kShaderProgramTypeCount];
+	ShaderProgram programs[ShaderProgramTypeCount];
 	VertexLayout vertexLayout;
 	uint32_t varation;
 	String name;
diff --git a/Source/Graphics/VertexLayout.h b/Source/Graphics/VertexLayout.h
index 28ac62c..c786714 100644
--- a/Source/Graphics/VertexLayout.h
+++ b/Source/Graphics/VertexLayout.h
@@ -6,8 +6,8 @@
 
 enum VertexAttributeType
 {
-	kVertexAttributeTypePosition,
-	kVertexAttributeTypeTexCoord0,
+	VertexAttributeTypePosition,
+	VertexAttributeTypeTexCoord0,
 };
 
 struct VertexAttributeLayout
diff --git a/Source/Log/LogModule.cpp b/Source/Log/LogModule.cpp
index 55e2f95..eb801ba 100644
--- a/Source/Log/LogModule.cpp
+++ b/Source/Log/LogModule.cpp
@@ -7,14 +7,14 @@ LogModule::LogModule(uint32_t bufferCount, uint32_t workersCount) : CmdModule(bu
 SERIALIZE_METHOD_ARG1(LogModule, Message, const char*);
 
 DECLARE_COMMAND_CODE(MessageF);
-void LogModule::RecordMessageF(const ExecutionContext& context, const char* format, ...)
+void LogModule::RecMessageF(const ExecutionContext& context, const char* format, ...)
 {
 	va_list arguments;
 	va_start(arguments, format);
 
 	auto buffer = GetRecordingBuffer(context);
 	auto& stream = buffer->stream;
-	stream.Write(kCommandCodeMessageF);
+	stream.Write(CommandCodeMessageF);
 	stream.Write(format);
 	stream.Write(arguments);
 	buffer->commandCount++;
diff --git a/Source/Log/LogModule.h b/Source/Log/LogModule.h
index cd3166a..7ae4749 100644
--- a/Source/Log/LogModule.h
+++ b/Source/Log/LogModule.h
@@ -7,8 +7,8 @@ class LogModule : public CmdModule
 {
 public:
 	LogModule(uint32_t bufferCount, uint32_t workersCount);
-	void RecordMessage(const ExecutionContext& context, const char* name);
-	void RecordMessageF(const ExecutionContext& context, const char* format, ...);
+	void RecMessage(const ExecutionContext& context, const char* name);
+	void RecMessageF(const ExecutionContext& context, const char* format, ...);
 
 protected:
 	virtual bool ExecuteCommand(const ExecutionContext& context, IOStream& stream, uint32_t commandCode) override;
diff --git a/Source/Math/Color.h b/Source/Math/Color.h
index 1e99c17..1d73538 100644
--- a/Source/Math/Color.h
+++ b/Source/Math/Color.h
@@ -4,9 +4,9 @@
 
 enum ColorFormat
 {
-	kColorFormatR32G32B32A32,
-	kColorFormatR32G32B32,
-	kColorFormatR32G32,
+	ColorFormatR32G32B32A32,
+	ColorFormatR32G32B32,
+	ColorFormatR32G32,
 };
 
 // RGBA
diff --git a/Source/Modules/CmdBufferPoolModule.cpp b/Source/Modules/CmdBufferPoolModule.cpp
index c508e7b..a527688 100644
--- a/Source/Modules/CmdBufferPoolModule.cpp
+++ b/Source/Modules/CmdBufferPoolModule.cpp
@@ -18,10 +18,10 @@ void CmdBufferPoolModule::Execute(const ExecutionContext & context)
 	{
 		auto& poolContext = contexts[i];
 		for (auto buffer : poolContext.cmdBuffers)
-			if (buffer->state == kCmdBufferStateExecuted)
+			if (buffer->state == CmdBufferStateExecuted)
 			{
 				poolContext.readyCmdBuffers.push(buffer);
-				buffer->state = kCmdBufferStateNotUsed;
+				buffer->state = CmdBufferStateNotUsed;
 			}
 	}
 }
@@ -52,11 +52,11 @@ CmdBuffer* CmdBufferPoolModule::Pull(const ExecutionContext& context, uint64_t i
 
 void CmdBufferPoolModule::Reset(CmdBuffer* buffer, uint64_t index, const ExecutionContext& context)
 {
-	ASSERT(buffer->state == kCmdBufferStateNotUsed);
+	ASSERT(buffer->state == CmdBufferStateNotUsed);
 	buffer->stream.Reset();
 	buffer->commandCount = 0;
 	buffer->index = index;
 	buffer->workerIndex = context.workerIndex;
 	buffer->executingModule = context.executingModule;
-	buffer->state = kCmdBufferStateUsed;
+	buffer->state = CmdBufferStateUsed;
 }
diff --git a/Source/Modules/CmdBufferPoolModule.h b/Source/Modules/CmdBufferPoolModule.h
index e9203cd..dd3bc2d 100644
--- a/Source/Modules/CmdBufferPoolModule.h
+++ b/Source/Modules/CmdBufferPoolModule.h
@@ -8,22 +8,22 @@
 
 enum CmdBufferState
 {
-	kCmdBufferStateNotUsed,
-	kCmdBufferStateUsed,
-	kCmdBufferStateExecuted,
+	CmdBufferStateNotUsed,
+	CmdBufferStateUsed,
+	CmdBufferStateExecuted,
 };
 
 struct CmdBuffer
 {
 	CmdBuffer() : 
 		commandCount(0),
-		state(kCmdBufferStateNotUsed)
+		state(CmdBufferStateNotUsed)
 	{}
 
-	/// Recorded commands buffer
+	/// Reced commands buffer
 	IOStream stream;
 
-	/// Recorded commandcount
+	/// Reced commandcount
 	size_t commandCount;
 
 	/// Index of the cmdbuffer
diff --git a/Source/Modules/CmdModule.cpp b/Source/Modules/CmdModule.cpp
index 5846c59..87f29cf 100644
--- a/Source/Modules/CmdModule.cpp
+++ b/Source/Modules/CmdModule.cpp
@@ -36,7 +36,7 @@ CmdBuffer* CmdModule::GetRecordingBuffer(const ExecutionContext& context)
 	return buffer;
 }
 
-size_t CmdModule::GetExecutionkSize() { return 1; }
+size_t CmdModule::GetExecutionSize() { return 1; }
 
 void CmdModule::Execute(const ExecutionContext& context)
 {
@@ -58,12 +58,11 @@ void CmdModule::Execute(const ExecutionContext& context)
 		// Reset buffer for executing
 		auto& stream = buffer->stream;
 		buffer->stream.Reset();
-		buffer->state = kCmdBufferStateExecuted;
+		buffer->state = CmdBufferStateExecuted;
 
 		for (int i = 0; i < buffer->commandCount; i++)
 		{
-			uint32_t commandCode;
-			stream.Read(commandCode);
+			auto& commandCode = stream.FastRead<uint32_t>();
 			ASSERT(ExecuteCommand(context, stream, commandCode));
 		}
 	}
diff --git a/Source/Modules/CmdModule.h b/Source/Modules/CmdModule.h
index 6c7e581..a06adca 100644
--- a/Source/Modules/CmdModule.h
+++ b/Source/Modules/CmdModule.h
@@ -6,46 +6,76 @@
 #include <Modules\CmdModuleHelper.h>
 #include <Modules\CmdBufferPoolModule.h>
 
-#define DESERIALIZE_METHOD_START(Name) \
-	case kCommandCode##Name: { \
+/*#define DESERIALIZE_METHOD_START(Name) \
+	case CommandCode##Name: { \
 	EXT_TRACE("%s::%s index=%d", GetName(), #Name, context.workerIndex);
 
 #define DESERIALIZE_METHOD_ARG1_START(Name, ArgumentType1, ArgumentName1) \
-	case kCommandCode##Name: { \
+	case CommandCode##Name: { \
 	ArgumentType1 ArgumentName1; stream.Read(ArgumentName1); \
 	EXT_TRACE("%s::%s index=%d", GetName(), #Name, context.workerIndex);
 
 #define DESERIALIZE_METHOD_ARG2_START(Name, ArgumentType1, ArgumentName1, ArgumentType2, ArgumentName2) \
-	case kCommandCode##Name: { \
+	case CommandCode##Name: { \
 	ArgumentType1 ArgumentName1; stream.Read(ArgumentName1); \
 	ArgumentType2 ArgumentName2; stream.Read(ArgumentName2); \
 	EXT_TRACE("%s::%s index=%d", GetName(), #Name, context.workerIndex);
 
 #define DESERIALIZE_METHOD_ARG3_START(Name, ArgumentType1, ArgumentName1, ArgumentType2, ArgumentName2, ArgumentType3, ArgumentName3) \
-	case kCommandCode##Name: { \
+	case CommandCode##Name: { \
 	ArgumentType1 ArgumentName1; stream.Read(ArgumentName1); \
 	ArgumentType2 ArgumentName2; stream.Read(ArgumentName2); \
 	ArgumentType3 ArgumentName3; stream.Read(ArgumentName3); \
 	EXT_TRACE("%s::%s index=%d", GetName(), #Name, context.workerIndex);
 
 #define DESERIALIZE_METHOD_ARG4_START(Name, ArgumentType1, ArgumentName1, ArgumentType2, ArgumentName2, ArgumentType3, ArgumentName3, ArgumentType4, ArgumentName4) \
-	case kCommandCode##Name: { \
+	case CommandCode##Name: { \
 	ArgumentType1 ArgumentName1; stream.Read(ArgumentName1); \
 	ArgumentType2 ArgumentName2; stream.Read(ArgumentName2); \
 	ArgumentType3 ArgumentName3; stream.Read(ArgumentName3); \
 	ArgumentType4 ArgumentName4; stream.Read(ArgumentName4); \
+	EXT_TRACE("%s::%s index=%d", GetName(), #Name, context.workerIndex);*/
+
+#define DESERIALIZE_METHOD_START(Name) \
+	case CommandCode##Name: { \
+	EXT_TRACE("%s::%s index=%d", GetName(), #Name, context.workerIndex);
+
+#define DESERIALIZE_METHOD_ARG1_START(Name, ArgumentType1, ArgumentName1) \
+	case CommandCode##Name: { \
+	ArgumentType1& ArgumentName1 = stream.FastRead<ArgumentType1>(); \
+	EXT_TRACE("%s::%s index=%d", GetName(), #Name, context.workerIndex);
+
+#define DESERIALIZE_METHOD_ARG2_START(Name, ArgumentType1, ArgumentName1, ArgumentType2, ArgumentName2) \
+	case CommandCode##Name: { \
+	ArgumentType1& ArgumentName1 = stream.FastRead<ArgumentType1>(); \
+	ArgumentType2& ArgumentName2 = stream.FastRead<ArgumentType2>(); \
+	EXT_TRACE("%s::%s index=%d", GetName(), #Name, context.workerIndex);
+
+#define DESERIALIZE_METHOD_ARG3_START(Name, ArgumentType1, ArgumentName1, ArgumentType2, ArgumentName2, ArgumentType3, ArgumentName3) \
+	case CommandCode##Name: { \
+	ArgumentType1& ArgumentName1 = stream.FastRead<ArgumentType1>(); \
+	ArgumentType2& ArgumentName2 = stream.FastRead<ArgumentType2>(); \
+	ArgumentType3& ArgumentName3 = stream.FastRead<ArgumentType3>(); \
+	EXT_TRACE("%s::%s index=%d", GetName(), #Name, context.workerIndex);
+
+#define DESERIALIZE_METHOD_ARG4_START(Name, ArgumentType1, ArgumentName1, ArgumentType2, ArgumentName2, ArgumentType3, ArgumentName3, ArgumentType4, ArgumentName4) \
+	case CommandCode##Name: { \
+	ArgumentType1& ArgumentName1 = stream.FastRead<ArgumentType1>(); \
+	ArgumentType2& ArgumentName2 = stream.FastRead<ArgumentType2>(); \
+	ArgumentType3& ArgumentName3 = stream.FastRead<ArgumentType3>(); \
+	ArgumentType4& ArgumentName4 = stream.FastRead<ArgumentType4>(); \
 	EXT_TRACE("%s::%s index=%d", GetName(), #Name, context.workerIndex);
 
 #define DESERIALIZE_METHOD_END return true; }
 
 #define SERIALIZE_METHOD_RESOURCE(Module, ReturnType, CreateType) \
 	DECLARE_COMMAND_CODE(Create##ReturnType); \
-	const ReturnType* Module::RecordCreate##ReturnType(const ExecutionContext& context) \
+	const ReturnType* Module::RecCreate##ReturnType(const ExecutionContext& context) \
 	{ \
 		auto unit = (ReturnType*)new CreateType(); \
 		auto buffer = GetRecordingBuffer(context); \
 		auto& stream = buffer->stream; \
-		stream.Write(kCommandCodeCreate##ReturnType); \
+		stream.Write(CommandCodeCreate##ReturnType); \
 		stream.Write(unit); \
 		buffer->commandCount++; \
 		return unit; \
@@ -53,12 +83,12 @@
 
 #define SERIALIZE_METHOD_RESOURCE2(Module, ReturnType, CreateType, ArgumentType1, ArgumentType2) \
 	DECLARE_COMMAND_CODE(Create##ReturnType); \
-	const ReturnType* Module::RecordCreate##ReturnType(const ExecutionContext& context, ArgumentType1 argument1, ArgumentType2 argument2) \
+	const ReturnType* Module::RecCreate##ReturnType(const ExecutionContext& context, ArgumentType1 argument1, ArgumentType2 argument2) \
 	{ \
 		auto unit = (ReturnType*)new CreateType(); \
 		auto buffer = GetRecordingBuffer(context); \
 		auto& stream = buffer->stream; \
-		stream.Write(kCommandCodeCreate##ReturnType); \
+		stream.Write(CommandCodeCreate##ReturnType); \
 		stream.Write(unit); \
 		stream.Write(argument1); \
 		stream.Write(argument2); \
@@ -74,7 +104,7 @@ public:
 	CmdModule(uint32_t bufferCount, uint32_t workersCount);
 	virtual void SetupExecuteOrder(ModuleManager* moduleManager) override;
 	virtual void Execute(const ExecutionContext& context) override;
-	virtual size_t GetExecutionkSize() override;
+	virtual size_t GetExecutionSize() override;
 
 protected:
 	virtual bool ExecuteCommand(const ExecutionContext& context, IOStream& stream, uint32_t commandCode) = 0;
diff --git a/Source/Modules/CmdModuleHelper.h b/Source/Modules/CmdModuleHelper.h
index e8c6bf4..3087136 100644
--- a/Source/Modules/CmdModuleHelper.h
+++ b/Source/Modules/CmdModuleHelper.h
@@ -3,16 +3,16 @@
 #define NOARG
 #define COMMA ,
 
-#define DECLARE_COMMAND_CODE(Name) static const int kCommandCode##Name = __COUNTER__;
+#define DECLARE_COMMAND_CODE(Name) static const int CommandCode##Name = __COUNTER__;
 
 #define SERIALIZE_METHOD_TEMPLATE(Module, Name, ReturnType, DeclareArguments, WriteArguments, BodyPrefix, BodyPostFix) \
 	DECLARE_COMMAND_CODE(Name); \
-	ReturnType Module::Record##Name(const ExecutionContext& context DeclareArguments) \
+	ReturnType Module::Rec##Name(const ExecutionContext& context DeclareArguments) \
 	{ \
 		auto buffer = GetRecordingBuffer(context); \
 		auto& stream = buffer->stream; \
 		BodyPrefix \
-		stream.Write(kCommandCode##Name); \
+		stream.Write(CommandCode##Name); \
 		WriteArguments \
 		buffer->commandCount++; \
 		BodyPostFix \
@@ -66,8 +66,8 @@
 	}
 
 #define SERIALIZE_METHOD_BATCH_ARG1(Module, Name, BatchName, ArgumentType1) \
-	 SERIALIZE_METHOD_TEMPLATE(Module, Name, void, COMMA ArgumentType1 argument1, stream.Write(argument1);, SERIALIZE_BATCH(kCommandCode##BatchName, argument1), NOARG)
+	 SERIALIZE_METHOD_TEMPLATE(Module, Name, void, COMMA ArgumentType1 argument1, stream.Write(argument1);, SERIALIZE_BATCH(CommandCode##BatchName, argument1), NOARG)
 #define SERIALIZE_METHOD_BATCH_ARG2(Module, Name, BatchName, ArgumentType1, ArgumentType2) \
-	 SERIALIZE_METHOD_TEMPLATE(Module, Name, void, COMMA ArgumentType1 argument1 COMMA ArgumentType2 argument2, stream.Write(argument1); stream.Write(argument2);, SERIALIZE_BATCH(kCommandCode##BatchName, argument1), NOARG)
+	 SERIALIZE_METHOD_TEMPLATE(Module, Name, void, COMMA ArgumentType1 argument1 COMMA ArgumentType2 argument2, stream.Write(argument1); stream.Write(argument2);, SERIALIZE_BATCH(CommandCode##BatchName, argument1), NOARG)
 #define SERIALIZE_METHOD_BATCH_ARG3(Module, Name, BatchName, ArgumentType1, ArgumentType2, ArgumentType3) \
-	 SERIALIZE_METHOD_TEMPLATE(Module, Name, void, COMMA ArgumentType1 argument1 COMMA ArgumentType2 argument2 COMMA ArgumentType3 argument3, stream.Write(argument1); stream.Write(argument2); stream.Write(argument3);, SERIALIZE_BATCH(kCommandCode##BatchName, argument1), NOARG)
\ No newline at end of file
+	 SERIALIZE_METHOD_TEMPLATE(Module, Name, void, COMMA ArgumentType1 argument1 COMMA ArgumentType2 argument2 COMMA ArgumentType3 argument3, stream.Write(argument1); stream.Write(argument2); stream.Write(argument3);, SERIALIZE_BATCH(CommandCode##BatchName, argument1), NOARG)
\ No newline at end of file
diff --git a/Source/Modules/Module.h b/Source/Modules/Module.h
index 9f7f00e..31d136e 100644
--- a/Source/Modules/Module.h
+++ b/Source/Modules/Module.h
@@ -22,7 +22,7 @@ public:
 	Module() {}
 	virtual void SetupExecuteOrder(ModuleManager* moduleManager) {}
 	virtual void Execute(const ExecutionContext& context) = 0;
-	virtual size_t GetExecutionkSize() { return 1; }
+	virtual size_t GetExecutionSize() { return 1; }
 	virtual size_t GetSplitExecutionSize(size_t currentSize) { return 1; }
 	virtual const char* GetName() { return "Unamed";  }
 
diff --git a/Source/Modules/StaticModulePlanner.cpp b/Source/Modules/StaticModulePlanner.cpp
index 8a8ef1f..80387a8 100644
--- a/Source/Modules/StaticModulePlanner.cpp
+++ b/Source/Modules/StaticModulePlanner.cpp
@@ -128,7 +128,7 @@ void StaticModulePlanner::Reset()
 		ModuleJob job;
 		job.module = child->module;
 		job.offset = 0;
-		job.size = job.module->GetExecutionkSize();
+		job.size = job.module->GetExecutionSize();
 		job.userData = child;
 		readyJobs.push(job);
 	}
@@ -193,7 +193,7 @@ void StaticModulePlanner::SetFinished(ModuleJob job)
 		ModuleJob childJob;
 		childJob.module = child->module;
 		childJob.offset = 0;
-		childJob.size = childJob.module->GetExecutionkSize();
+		childJob.size = childJob.module->GetExecutionSize();
 		childJob.userData = child;
 		readyJobs.push(childJob);
 	}
diff --git a/Source/Modules/UnitModule.cpp b/Source/Modules/UnitModule.cpp
index 80a7b7e..7cf6c6c 100644
--- a/Source/Modules/UnitModule.cpp
+++ b/Source/Modules/UnitModule.cpp
@@ -17,7 +17,7 @@ bool UnitModule::ExecuteCommand(const ExecutionContext& context, IOStream& strea
 		DESERIALIZE_METHOD_ARG1_START(Destroy, Unit*, unit);
 		units.remove(unit);
 		for (auto component : unit->components)
-			component->module->RecordDestroy(context, component);
+			component->module->RecDestroy(context, component);
 		DESERIALIZE_METHOD_END;
 
 		DESERIALIZE_METHOD_ARG2_START(AddComponent, Unit*, unit, Component*, component);
diff --git a/Source/Modules/UnitModule.h b/Source/Modules/UnitModule.h
index 1cd4d5d..ccf7c25 100644
--- a/Source/Modules/UnitModule.h
+++ b/Source/Modules/UnitModule.h
@@ -6,12 +6,12 @@
 
 #define RECORD_CMD_CREATE2(Module, ReturnType, CreateType) \
 	DECLARE_COMMAND_CODE(Create##ReturnType); \
-	const ReturnType* Module::RecordCreate##ReturnType(const ExecutionContext& context) \
+	const ReturnType* Module::RecCreate##ReturnType(const ExecutionContext& context) \
 	{ \
 		ReturnType* unit = (ReturnType*)new CreateType(this); \
 		auto buffer = GetRecordingBuffer(context); \
 		auto& stream = buffer->stream; \
-		stream.Write(kCommandCodeCreate##ReturnType); \
+		stream.Write(CommandCodeCreate##ReturnType); \
 		stream.Write(unit); \
 		buffer->commandCount++; \
 		return unit; \
@@ -41,7 +41,7 @@ public:
 	{
 	}
 
-	virtual void RecordDestroy(const ExecutionContext& context, const Component* unit) = 0;
+	virtual void RecDestroy(const ExecutionContext& context, const Component* unit) = 0;
 };
 
 struct Unit
@@ -58,9 +58,9 @@ class UnitModule : public CmdModule
 {
 public:
 	UnitModule(uint32_t bufferCount, uint32_t workersCount);
-	const Unit* RecordCreateUnit(const ExecutionContext& context);
-	void RecordDestroy(const ExecutionContext& context, const Unit* unit);
-	void RecordAddComponent(const ExecutionContext& context, const Unit* unit, const Component* component);
+	const Unit* RecCreateUnit(const ExecutionContext& context);
+	void RecDestroy(const ExecutionContext& context, const Unit* unit);
+	void RecAddComponent(const ExecutionContext& context, const Unit* unit, const Component* component);
 
 	template<class T>
 	const T* GetComponent(const Component* target)
diff --git a/Source/Rendering/CameraModule.cpp b/Source/Rendering/CameraModule.cpp
index acab97d..c92200b 100644
--- a/Source/Rendering/CameraModule.cpp
+++ b/Source/Rendering/CameraModule.cpp
@@ -24,24 +24,24 @@ void CameraModule::Execute(const ExecutionContext& context)
 	for (auto target : cameras)
 	{
 		auto transform = unitModule->GetComponent<Transform>(target);
-		transformModule->RecordCalculateWorldToView(context, transform);
+		transformModule->RecCalculateWorldToView(context, transform);
 		target->worldToCameraMatrix = transform->worldToView;
 		target->worldToCameraMatrix.Multiply(target->projectionMatrix);
 		target->worldToCameraMatrix = Matrix4x4f::Transpose(target->worldToCameraMatrix);
-		storageModule->RecordUpdateStorage(context, target->perCameraStorage, 0, Range<void>(&target->worldToCameraMatrix, sizeof(Matrix4x4f)));
+		storageModule->RecUpdateStorage(context, target->perCameraStorage, 0, Range<void>(&target->worldToCameraMatrix, sizeof(Matrix4x4f)));
 	}
 }
 
-const List<Camera*>& CameraModule::GetCameras() { return cameras; }
+const List<Camera*>& CameraModule::GetCameras() const { return cameras; }
 
 DECLARE_COMMAND_CODE(CreateCamera);
-const Camera* CameraModule::RecordCreateCamera(const ExecutionContext& context)
+const Camera* CameraModule::RecCreateCamera(const ExecutionContext& context)
 {
 	auto buffer = GetRecordingBuffer(context);
 	auto& stream = buffer->stream;
-	auto storage = storageModule->RecordCreateStorage(context, sizeof(Matrix4x4f));
+	auto storage = storageModule->RecCreateStorage(context, sizeof(Matrix4x4f));
 	auto target = new Camera(this, storage);
-	stream.Write(kCommandCodeCreateCamera);
+	stream.Write(CommandCodeCreateCamera);
 	stream.Write(target);
 	buffer->commandCount++;
 	return target;
diff --git a/Source/Rendering/CameraModule.h b/Source/Rendering/CameraModule.h
index 01eca7b..0366b7e 100644
--- a/Source/Rendering/CameraModule.h
+++ b/Source/Rendering/CameraModule.h
@@ -42,10 +42,12 @@ public:
 	CameraModule(uint32_t bufferCount, uint32_t workersCount);
 	virtual void Execute(const ExecutionContext& context) override;
 	virtual void SetupExecuteOrder(ModuleManager* moduleManager) override;
-	const Camera* RecordCreateCamera(const ExecutionContext& context);
-	virtual void RecordDestroy(const ExecutionContext& context, const Component* target) override;
-	void RecordSetSurface(const ExecutionContext& context, const Camera* camera, const Surface* surface);
-	const List<Camera*>& GetCameras();
+	const Camera* RecCreateCamera(const ExecutionContext& context);
+	virtual void RecDestroy(const ExecutionContext& context, const Component* target) override;
+	void RecSetSurface(const ExecutionContext& context, const Camera* camera, const Surface* surface);
+
+public:
+	const List<Camera*>& GetCameras() const;
 
 protected:
 	virtual bool ExecuteCommand(const ExecutionContext& context, IOStream& stream, uint32_t commandCode) override;
diff --git a/Source/Rendering/ImageModule.cpp b/Source/Rendering/ImageModule.cpp
index 5626032..dd11924 100644
--- a/Source/Rendering/ImageModule.cpp
+++ b/Source/Rendering/ImageModule.cpp
@@ -13,13 +13,13 @@ void ImageModule::SetupExecuteOrder(ModuleManager* moduleManager)
 }
 
 DECLARE_COMMAND_CODE(CreateImage);
-const Image* ImageModule::RecordCreateImage(const ExecutionContext& context, uint32_t width, uint32_t height)
+const Image* ImageModule::RecCreateImage(const ExecutionContext& context, uint32_t width, uint32_t height)
 {
 	auto buffer = GetRecordingBuffer(context);
 	auto& stream = buffer->stream;
-	auto texture = graphicsModule->RecordCreateITexture(context, width, height);
+	auto texture = graphicsModule->RecCreateITexture(context, width, height);
 	auto target = new Image(texture);
-	stream.Write(kCommandCodeCreateImage);
+	stream.Write(CommandCodeCreateImage);
 	stream.Write(target);
 	buffer->commandCount++;
 	return target;
diff --git a/Source/Rendering/ImageModule.h b/Source/Rendering/ImageModule.h
index d874a7f..302c817 100644
--- a/Source/Rendering/ImageModule.h
+++ b/Source/Rendering/ImageModule.h
@@ -26,8 +26,8 @@ class ImageModule : public CmdModule
 public:
 	ImageModule(uint32_t bufferCount, uint32_t workersCount);
 	virtual void SetupExecuteOrder(ModuleManager* moduleManager) override;
-	const Image* RecordCreateImage(const ExecutionContext& context, uint32_t width, uint32_t height);
-	void RecordSetSampler(const ExecutionContext& context, const Image* image, const Sampler* sampler);
+	const Image* RecCreateImage(const ExecutionContext& context, uint32_t width, uint32_t height);
+	void RecSetSampler(const ExecutionContext& context, const Image* image, const Sampler* sampler);
 
 protected:
 	virtual bool ExecuteCommand(const ExecutionContext& context, IOStream& stream, uint32_t commandCode) override;
diff --git a/Source/Rendering/MaterialModule.cpp b/Source/Rendering/MaterialModule.cpp
index cd304f2..bc42808 100644
--- a/Source/Rendering/MaterialModule.cpp
+++ b/Source/Rendering/MaterialModule.cpp
@@ -14,13 +14,13 @@ void MaterialModule::SetupExecuteOrder(ModuleManager* moduleManager)
 }
 
 DECLARE_COMMAND_CODE(CreateMaterial);
-const Material* MaterialModule::RecordCreateMaterial(const ExecutionContext& context)
+const Material* MaterialModule::RecCreateMaterial(const ExecutionContext& context)
 {
 	auto buffer = GetRecordingBuffer(context);
 	auto& stream = buffer->stream;
 	auto properties = new MaterialProperties();
 	auto target = new Material(properties);
-	stream.Write(kCommandCodeCreateMaterial);
+	stream.Write(CommandCodeCreateMaterial);
 	stream.Write(target);
 	buffer->commandCount++;
 	return target;
@@ -50,7 +50,7 @@ bool MaterialModule::ExecuteCommand(const ExecutionContext& context, IOStream& s
 		material->shader = shader;
 		for (auto shaderPipeline : shader->pipelines)
 		{
-			auto properties = graphicsModule->RecordCreateIShaderArguments(context, shaderPipeline);
+			auto properties = graphicsModule->RecCreateIShaderArguments(context, shaderPipeline);
 			auto pipeline = new MaterialPipeline(shaderPipeline, properties);
 			material->pipelines.push_back(pipeline);
 		}
@@ -62,9 +62,9 @@ bool MaterialModule::ExecuteCommand(const ExecutionContext& context, IOStream& s
 			{
 				switch (property.type)
 				{
-				case kMaterialPropertyTypeStorage:
+				case MaterialPropertyTypeStorage:
 					auto storage = (const Storage*) property.value;
-					graphicsModule->RecordSetBuffer(context, pipeline->properties, property.name.c_str(), storage->buffer);
+					graphicsModule->RecSetBuffer(context, pipeline->properties, property.name.c_str(), storage->buffer);
 				}
 			}
 		}
@@ -73,10 +73,10 @@ bool MaterialModule::ExecuteCommand(const ExecutionContext& context, IOStream& s
 
 		DESERIALIZE_METHOD_ARG3_START(SetStorage, Material*, material, const char*, name, const Storage*, storage);
 		auto materialProperties = (MaterialProperties*) material->properties;
-		SetProperty(materialProperties, name, kMaterialPropertyTypeStorage, (void*) storage);
+		SetProperty(materialProperties, name, MaterialPropertyTypeStorage, (void*) storage);
 		for (auto pipeline : material->pipelines)
 		{
-			graphicsModule->RecordSetBuffer(context, pipeline->properties, name, storage->buffer);
+			graphicsModule->RecSetBuffer(context, pipeline->properties, name, storage->buffer);
 		}
 		DESERIALIZE_METHOD_END;
 	}
diff --git a/Source/Rendering/MaterialModule.h b/Source/Rendering/MaterialModule.h
index a7a8a9a..2751b97 100644
--- a/Source/Rendering/MaterialModule.h
+++ b/Source/Rendering/MaterialModule.h
@@ -9,7 +9,7 @@
 
 enum MaterialPropertyType
 {
-	kMaterialPropertyTypeStorage,
+	MaterialPropertyTypeStorage,
 };
 
 struct MaterialProperty
@@ -55,9 +55,9 @@ class MaterialModule : public CmdModule
 public:
 	MaterialModule(uint32_t bufferCount, uint32_t workersCount);
 	virtual void SetupExecuteOrder(ModuleManager* moduleManager) override;
-	const Material* RecordCreateMaterial(const ExecutionContext& context);
-	void RecordSetShader(const ExecutionContext& context, const Material* target, const Shader* shader);
-	void RecordSetStorage(const ExecutionContext& context, const Material* target, const char* name, const Storage* storage);
+	const Material* RecCreateMaterial(const ExecutionContext& context);
+	void RecSetShader(const ExecutionContext& context, const Material* target, const Shader* shader);
+	void RecSetStorage(const ExecutionContext& context, const Material* target, const char* name, const Storage* storage);
 
 protected:
 	virtual bool ExecuteCommand(const ExecutionContext& context, IOStream& stream, uint32_t commandCode) override;
diff --git a/Source/Rendering/MeshModule.cpp b/Source/Rendering/MeshModule.cpp
index 9fa6161..6c7b386 100644
--- a/Source/Rendering/MeshModule.cpp
+++ b/Source/Rendering/MeshModule.cpp
@@ -12,12 +12,12 @@ void MeshModule::SetupExecuteOrder(ModuleManager* moduleManager)
 }
 
 DECLARE_COMMAND_CODE(CreateMesh);
-const Mesh* MeshModule::RecordCreateMesh(const ExecutionContext& context, const VertexLayout& vertexLayout)
+const Mesh* MeshModule::RecCreateMesh(const ExecutionContext& context, const VertexLayout& vertexLayout)
 {
 	auto buffer = GetRecordingBuffer(context);
 	auto& stream = buffer->stream;
 	auto target = new Mesh(vertexLayout);
-	stream.Write(kCommandCodeCreateMesh);
+	stream.Write(CommandCodeCreateMesh);
 	stream.Write(target);
 	buffer->commandCount++;
 	return target;
@@ -37,8 +37,8 @@ bool MeshModule::ExecuteCommand(const ExecutionContext& context, IOStream& strea
 		DESERIALIZE_METHOD_ARG2_START(SetVertices, Mesh*, target, Range<uint8_t>, vertices);
 		target->vertices = vertices;
 
-		target->vertexBuffer = graphicsModule->RecordCreateIBuffer(context, vertices.size);
-		graphicsModule->RecordUpdateBuffer(context, target->vertexBuffer, (void*) target->vertices.pointer, target->vertices.size);
+		target->vertexBuffer = graphicsModule->RecCreateIBuffer(context, vertices.size);
+		graphicsModule->RecUpdateBuffer(context, target->vertexBuffer, (void*) target->vertices.pointer, target->vertices.size);
 		DESERIALIZE_METHOD_END;
 
 		DESERIALIZE_METHOD_ARG3_START(SetSubMesh, Mesh*, target, uint32_t, index, SubMesh, submesh);
diff --git a/Source/Rendering/MeshModule.h b/Source/Rendering/MeshModule.h
index 2643a3c..89cf53f 100644
--- a/Source/Rendering/MeshModule.h
+++ b/Source/Rendering/MeshModule.h
@@ -9,14 +9,14 @@
 
 enum MeshTopology
 {
-	kMeshTopologyTriangles,
+	MeshTopologyTriangles,
 };
 
 struct SubMesh
 {
 	SubMesh() {}
 	SubMesh(uint32_t offset, uint32_t size, MeshTopology topology) : offset(offset), size(size), topology(topology) {}
-	SubMesh(uint32_t size) : SubMesh(0, size, kMeshTopologyTriangles) {}
+	SubMesh(uint32_t size) : SubMesh(0, size, MeshTopologyTriangles) {}
 	uint32_t offset;
 	uint32_t size;
 	MeshTopology topology;
@@ -39,9 +39,9 @@ class MeshModule : public CmdModule
 public:
 	MeshModule(uint32_t bufferCount, uint32_t workersCount);
 	virtual void SetupExecuteOrder(ModuleManager* moduleManager) override;
-	const Mesh* RecordCreateMesh(const ExecutionContext& context, const VertexLayout& vertexLayout);
-	void RecordSetVertices(const ExecutionContext& context, const Mesh* target, const Range<uint8_t>& vertices);
-	void RecordSetSubMesh(const ExecutionContext& context, const Mesh* target, uint32_t index, const SubMesh& submesh);
+	const Mesh* RecCreateMesh(const ExecutionContext& context, const VertexLayout& vertexLayout);
+	void RecSetVertices(const ExecutionContext& context, const Mesh* target, const Range<uint8_t>& vertices);
+	void RecSetSubMesh(const ExecutionContext& context, const Mesh* target, uint32_t index, const SubMesh& submesh);
 
 protected:
 	virtual bool ExecuteCommand(const ExecutionContext& context, IOStream& stream, uint32_t commandCode) override;
diff --git a/Source/Rendering/MeshRendererModule.cpp b/Source/Rendering/MeshRendererModule.cpp
index d15fafd..128ab84 100644
--- a/Source/Rendering/MeshRendererModule.cpp
+++ b/Source/Rendering/MeshRendererModule.cpp
@@ -2,8 +2,9 @@
 #include <Transforms\TransformModule.h>
 #include <Graphics\IGraphicsModule.h>
 
-MeshRendererModule::MeshRendererModule(uint32_t bufferCount, uint32_t bufferIndexStep) :
-	ComponentModule(bufferCount, bufferIndexStep)
+MeshRendererModule::MeshRendererModule(uint32_t bufferCount, uint32_t bufferIndexStep) 
+	: ComponentModule(bufferCount, bufferIndexStep)
+	, perAllRendererStorage(nullptr)
 {
 }
 
@@ -19,16 +20,20 @@ void MeshRendererModule::SetupExecuteOrder(ModuleManager* moduleManager)
 
 void MeshRendererModule::Execute(const ExecutionContext& context)
 {
+	if (perAllRendererStorage == nullptr)
+		perAllRendererStorage = storageModule->RecCreateStorage(context, sizeof(Matrix4x4f));
+
 	CmdModule::Execute(context);
 
 	for (auto meshRenderer : meshRenderers)
 	{
 		auto transform = unitModule->GetComponent<Transform>(meshRenderer);
-		storageModule->RecordUpdateStorage(context, meshRenderer->perMeshStorage, 0, Range<void>(&transform->objectToWorld, sizeof(Matrix4x4f)));
+		storageModule->RecUpdateStorage(context, meshRenderer->perMeshStorage, 0, Range<void>(&transform->objectToWorld, sizeof(Matrix4x4f)));
 	}
 }
 
-const List<MeshRenderer*>& MeshRendererModule::GetMeshRenderers() { return meshRenderers; }
+const List<MeshRenderer*>& MeshRendererModule::GetMeshRenderers() const { return meshRenderers; }
+const Storage * MeshRendererModule::GetPerAllRendererStorage() const { return perAllRendererStorage; }
 
 SERIALIZE_METHOD_CREATECMP(MeshRendererModule, MeshRenderer);
 SERIALIZE_METHOD_ARG2(MeshRendererModule, SetMesh, const MeshRenderer*, const Mesh*);
@@ -40,7 +45,7 @@ bool MeshRendererModule::ExecuteCommand(const ExecutionContext& context, IOStrea
 	switch (commandCode)
 	{
 		DESERIALIZE_METHOD_ARG1_START(CreateMeshRenderer, MeshRenderer*, target);
-		target->perMeshStorage = storageModule->RecordCreateStorage(context, sizeof(Matrix4x4f));
+		target->perMeshStorage = storageModule->RecCreateStorage(context, sizeof(Matrix4x4f));
 		meshRenderers.push_back(target);
 		DESERIALIZE_METHOD_END;
 
@@ -50,6 +55,7 @@ bool MeshRendererModule::ExecuteCommand(const ExecutionContext& context, IOStrea
 
 		DESERIALIZE_METHOD_ARG2_START(SetMaterial, MeshRenderer*, target, const Material*, material);
 		target->material = material;
+		materialModule->RecSetStorage(context, target->material, "_perCameraData", perAllRendererStorage);
 		DESERIALIZE_METHOD_END;
 	}
 	return false;
diff --git a/Source/Rendering/MeshRendererModule.h b/Source/Rendering/MeshRendererModule.h
index 7ae2938..05cd6dd 100644
--- a/Source/Rendering/MeshRendererModule.h
+++ b/Source/Rendering/MeshRendererModule.h
@@ -27,11 +27,14 @@ public:
 	MeshRendererModule(uint32_t bufferCount, uint32_t workersCount);
 	virtual void SetupExecuteOrder(ModuleManager* moduleManager) override;
 	virtual void Execute(const ExecutionContext& context) override;
-	virtual void RecordDestroy(const ExecutionContext& context, const Component* target) override;
-	const MeshRenderer* RecordCreateMeshRenderer(const ExecutionContext& context);
-	void RecordSetMesh(const ExecutionContext& context, const MeshRenderer* target, const Mesh* mesh);
-	void RecordSetMaterial(const ExecutionContext& context, const MeshRenderer* target, const Material* material);
-	const List<MeshRenderer*>& GetMeshRenderers();
+	virtual void RecDestroy(const ExecutionContext& context, const Component* target) override;
+	const MeshRenderer* RecCreateMeshRenderer(const ExecutionContext& context);
+	void RecSetMesh(const ExecutionContext& context, const MeshRenderer* target, const Mesh* mesh);
+	void RecSetMaterial(const ExecutionContext& context, const MeshRenderer* target, const Material* material);
+
+public:
+	const List<MeshRenderer*>& GetMeshRenderers() const;
+	const Storage* GetPerAllRendererStorage() const;
 
 protected:
 	virtual bool ExecuteCommand(const ExecutionContext& context, IOStream& stream, uint32_t commandCode) override;
@@ -43,4 +46,5 @@ private:
 	StorageModule* storageModule;
 	TransformModule* transformModule;
 	UnitModule* unitModule;
+	const Storage* perAllRendererStorage;
 };
\ No newline at end of file
diff --git a/Source/Rendering/SamplerModule.cpp b/Source/Rendering/SamplerModule.cpp
index a9a0fac..e484ba5 100644
--- a/Source/Rendering/SamplerModule.cpp
+++ b/Source/Rendering/SamplerModule.cpp
@@ -12,13 +12,13 @@ void SamplerModule::SetupExecuteOrder(ModuleManager* moduleManager)
 }
 
 DECLARE_COMMAND_CODE(CreateSampler);
-const Sampler* SamplerModule::RecordCreateSampler(const ExecutionContext& context, const SamplerOptions& options)
+const Sampler* SamplerModule::RecCreateSampler(const ExecutionContext& context, const SamplerOptions& options)
 {
 	auto buffer = GetRecordingBuffer(context);
 	auto& stream = buffer->stream;
-	auto filter = graphicsModule->RecordCreateIFilter(context, options);
+	auto filter = graphicsModule->RecCreateIFilter(context, options);
 	auto target = new Sampler(options, filter);
-	stream.Write(kCommandCodeCreateSampler);
+	stream.Write(CommandCodeCreateSampler);
 	stream.Write(target);
 	buffer->commandCount++;
 	return target;
diff --git a/Source/Rendering/SamplerModule.h b/Source/Rendering/SamplerModule.h
index 9cd5708..4ac01c5 100644
--- a/Source/Rendering/SamplerModule.h
+++ b/Source/Rendering/SamplerModule.h
@@ -22,7 +22,7 @@ class SamplerModule : public CmdModule
 public:
 	SamplerModule(uint32_t bufferCount, uint32_t workersCount);
 	virtual void SetupExecuteOrder(ModuleManager* moduleManager) override;
-	const Sampler* RecordCreateSampler(const ExecutionContext& context, const SamplerOptions& options);
+	const Sampler* RecCreateSampler(const ExecutionContext& context, const SamplerOptions& options);
 
 	inline const Sampler* GetDefaultSampler() const { return samplers[0]; }
 
diff --git a/Source/Rendering/ShaderModule.cpp b/Source/Rendering/ShaderModule.cpp
index 0691dc7..f40a9fa 100644
--- a/Source/Rendering/ShaderModule.cpp
+++ b/Source/Rendering/ShaderModule.cpp
@@ -23,7 +23,7 @@ bool ShaderModule::ExecuteCommand(const ExecutionContext& context, IOStream& str
 		DESERIALIZE_METHOD_END;
 
 		DESERIALIZE_METHOD_ARG3_START(SetShaderPipeline, Shader*, target, uint32_t, index, const ShaderPipelineDesc*, desc);
-		auto pipeline = graphicsModule->RecordCreateIShaderPipeline(context, desc);
+		auto pipeline = graphicsModule->RecCreateIShaderPipeline(context, desc);
 		target->pipelines.push_back(pipeline);
 		DESERIALIZE_METHOD_END;
 	}
diff --git a/Source/Rendering/ShaderModule.h b/Source/Rendering/ShaderModule.h
index 45c314b..4556870 100644
--- a/Source/Rendering/ShaderModule.h
+++ b/Source/Rendering/ShaderModule.h
@@ -16,8 +16,8 @@ class ShaderModule : public CmdModule
 public:
 	ShaderModule(uint32_t bufferCount, uint32_t workersCount);
 	virtual void SetupExecuteOrder(ModuleManager* moduleManager) override;
-	const Shader* RecordCreateShader(const ExecutionContext& context);
-	void RecordSetShaderPipeline(const ExecutionContext& context, const Shader* target, uint32_t index, const ShaderPipelineDesc* desc);
+	const Shader* RecCreateShader(const ExecutionContext& context);
+	void RecSetShaderPipeline(const ExecutionContext& context, const Shader* target, uint32_t index, const ShaderPipelineDesc* desc);
 
 protected:
 	virtual bool ExecuteCommand(const ExecutionContext& context, IOStream& stream, uint32_t commandCode) override;
diff --git a/Source/Rendering/StorageModule.cpp b/Source/Rendering/StorageModule.cpp
index 85c8089..6b54e7c 100644
--- a/Source/Rendering/StorageModule.cpp
+++ b/Source/Rendering/StorageModule.cpp
@@ -12,13 +12,13 @@ void StorageModule::SetupExecuteOrder(ModuleManager* moduleManager)
 }
 
 DECLARE_COMMAND_CODE(CreateStorage);
-const Storage* StorageModule::RecordCreateStorage(const ExecutionContext& context, uint32_t size)
+const Storage* StorageModule::RecCreateStorage(const ExecutionContext& context, uint32_t size)
 {
 	auto buffer = GetRecordingBuffer(context);
 	auto& stream = buffer->stream;
-	auto gfxBuffer = graphicsModule->RecordCreateIBuffer(context, size);
+	auto gfxBuffer = graphicsModule->RecCreateIBuffer(context, size);
 	auto target = new Storage(gfxBuffer);
-	stream.Write(kCommandCodeCreateStorage);
+	stream.Write(CommandCodeCreateStorage);
 	stream.Write(target);
 	buffer->commandCount++;
 	return target;
@@ -31,12 +31,12 @@ bool StorageModule::ExecuteCommand(const ExecutionContext& context, IOStream& st
 	switch (commandCode)
 	{
 		DESERIALIZE_METHOD_ARG1_START(CreateStorage, Storage*, target);
-		target->buffer = graphicsModule->RecordCreateIBuffer(context, target->size);
+		target->buffer = graphicsModule->RecCreateIBuffer(context, target->size);
 		storages.push_back(target);
 		DESERIALIZE_METHOD_END
 
 		DESERIALIZE_METHOD_ARG3_START(UpdateStorage, Storage*, target, uint32_t, targetOffset, Range<void>, data);
-		graphicsModule->RecordUpdateBuffer(context, target->buffer, (void*)data.pointer, data.size);
+		graphicsModule->RecUpdateBuffer(context, target->buffer, (void*)data.pointer, data.size);
 		DESERIALIZE_METHOD_END
 	}
 	return false;
diff --git a/Source/Rendering/StorageModule.h b/Source/Rendering/StorageModule.h
index a0756c9..d3bc271 100644
--- a/Source/Rendering/StorageModule.h
+++ b/Source/Rendering/StorageModule.h
@@ -20,8 +20,8 @@ class StorageModule : public CmdModule
 public:
 	StorageModule(uint32_t bufferCount, uint32_t workersCount);
 	virtual void SetupExecuteOrder(ModuleManager* moduleManager) override;
-	const Storage* RecordCreateStorage(const ExecutionContext& context, uint32_t size);
-	void RecordUpdateStorage(const ExecutionContext& context, const Storage* target, uint32_t targetOffset, Range<void>& data);
+	const Storage* RecCreateStorage(const ExecutionContext& context, uint32_t size);
+	void RecUpdateStorage(const ExecutionContext& context, const Storage* target, uint32_t targetOffset, Range<void>& data);
 
 protected:
 	virtual bool ExecuteCommand(const ExecutionContext& context, IOStream& stream, uint32_t commandCode) override;
diff --git a/Source/Rendering/SurfaceModule.cpp b/Source/Rendering/SurfaceModule.cpp
index 9d248f9..66c987d 100644
--- a/Source/Rendering/SurfaceModule.cpp
+++ b/Source/Rendering/SurfaceModule.cpp
@@ -21,7 +21,7 @@ bool SurfaceModule::ExecuteCommand(const ExecutionContext& context, IOStream& st
 	switch (commandCode)
 	{
 		DESERIALIZE_METHOD_ARG1_START(CreateSurface, Surface*, target);
-		target->renderPass = graphicsModule->RecordCreateIRenderPass(context);
+		target->renderPass = graphicsModule->RecCreateIRenderPass(context);
 		surfaces.push_back(target);
 		DESERIALIZE_METHOD_END;
 
@@ -32,7 +32,7 @@ bool SurfaceModule::ExecuteCommand(const ExecutionContext& context, IOStream& st
 		attachment.loadAction = color.loadAction;
 		attachment.storeAction = color.storeAction;
 		attachment.clearColor = color.clearColor;
-		graphicsModule->RecordSetColorAttachment(context, target->renderPass, index, attachment);
+		graphicsModule->RecSetColorAttachment(context, target->renderPass, index, attachment);
 		DESERIALIZE_METHOD_END;
 
 		DESERIALIZE_METHOD_ARG2_START(SetDepth, Surface*, target, SurfaceDepth, depth);
@@ -42,11 +42,11 @@ bool SurfaceModule::ExecuteCommand(const ExecutionContext& context, IOStream& st
 		attachment.loadAction = depth.loadAction;
 		attachment.storeAction = depth.storeAction;
 		attachment.clearDepth = depth.clearDepth;
-		graphicsModule->RecordSetDepthAttachment(context, target->renderPass, attachment);
+		graphicsModule->RecSetDepthAttachment(context, target->renderPass, attachment);
 		DESERIALIZE_METHOD_END;
 
 		DESERIALIZE_METHOD_ARG2_START(SetViewport, Surface*, target, Viewport, viewport);
-		graphicsModule->RecordSetViewport(context, target->renderPass, viewport);
+		graphicsModule->RecSetViewport(context, target->renderPass, viewport);
 		DESERIALIZE_METHOD_END;
 	}
 	return false;
diff --git a/Source/Rendering/SurfaceModule.h b/Source/Rendering/SurfaceModule.h
index 78dccc4..b7b1c3e 100644
--- a/Source/Rendering/SurfaceModule.h
+++ b/Source/Rendering/SurfaceModule.h
@@ -11,8 +11,8 @@ struct SurfaceColor
 	SurfaceColor() {}
 	SurfaceColor(const Image* image) :
 		image(image),
-		loadAction(kLoadActionClear),
-		storeAction(kStoreActionStore),
+		loadAction(LoadActionClear),
+		storeAction(StoreActionStore),
 		clearColor(0, 0.2f, 0.4f, 0)
 	{
 	}
@@ -53,10 +53,10 @@ class SurfaceModule : public CmdModule
 public:
 	SurfaceModule(uint32_t bufferCount, uint32_t workersCount);
 	virtual void SetupExecuteOrder(ModuleManager* moduleManager) override;
-	const Surface* RecordCreateSurface(const ExecutionContext& context);
-	void RecordSetColor(const ExecutionContext& context, const Surface* target, uint32_t index, const SurfaceColor& color);
-	void RecordSetDepth(const ExecutionContext& context, const Surface* target, const SurfaceDepth& depth);
-	void RecordSetViewport(const ExecutionContext& context, const Surface* target, const Viewport& viewport);
+	const Surface* RecCreateSurface(const ExecutionContext& context);
+	void RecSetColor(const ExecutionContext& context, const Surface* target, uint32_t index, const SurfaceColor& color);
+	void RecSetDepth(const ExecutionContext& context, const Surface* target, const SurfaceDepth& depth);
+	void RecSetViewport(const ExecutionContext& context, const Surface* target, const Viewport& viewport);
 
 protected:
 	virtual bool ExecuteCommand(const ExecutionContext& context, IOStream& stream, uint32_t commandCode) override;
diff --git a/Source/Rendering/UnlitRenderingLoop/UnlitRenderingLoopModule.cpp b/Source/Rendering/UnlitRenderingLoop/UnlitRenderingLoopModule.cpp
index 6eb46bf..f3529c3 100644
--- a/Source/Rendering/UnlitRenderingLoop/UnlitRenderingLoopModule.cpp
+++ b/Source/Rendering/UnlitRenderingLoop/UnlitRenderingLoopModule.cpp
@@ -1,5 +1,6 @@
 #include <Rendering\UnlitRenderingLoop\UnlitRenderingLoopModule.h>
 #include <Rendering\MaterialModule.h>
+#include <Rendering\StorageModule.h>
 
 UnlitRenderingLoopModule::UnlitRenderingLoopModule(uint32_t bufferCount, uint32_t workersCount) :
 	CmdModule(bufferCount, workersCount)
@@ -14,6 +15,7 @@ void UnlitRenderingLoopModule::SetupExecuteOrder(ModuleManager* moduleManager)
 	graphicsModule = ExecuteAfter<IGraphicsModule>(moduleManager);
 	viewModule = ExecuteAfter<IViewModule>(moduleManager);
 	materialModule = ExecuteAfter<MaterialModule>(moduleManager);
+	storageModule = ExecuteAfter<StorageModule>(moduleManager);
 }
 
 void UnlitRenderingLoopModule::Execute(const ExecutionContext& context)
@@ -23,14 +25,17 @@ void UnlitRenderingLoopModule::Execute(const ExecutionContext& context)
 
 	auto& cameras = cameraModule->GetCameras();
 	auto& meshRenderers = meshRendererModule->GetMeshRenderers();
+	auto perAllRendererStorage = meshRendererModule->GetPerAllRendererStorage();
 	for (auto camera : cameras)
 	{
 		auto surface = camera->surface;
 		if (surface == nullptr)
 			continue;
 
-		graphicsModule->RecordPushDebug(context, "Camera.Render");
-		graphicsModule->RecordSetRenderPass(context, surface->renderPass);
+		storageModule->RecUpdateStorage(context, perAllRendererStorage, 0, Range<void>(&camera->worldToCameraMatrix, sizeof(Matrix4x4f)));
+
+		graphicsModule->RecPushDebug(context, "Camera.Render");
+		graphicsModule->RecSetRenderPass(context, surface->renderPass);
 
 		for (auto meshRenderer : meshRenderers)
 		{
@@ -42,34 +47,34 @@ void UnlitRenderingLoopModule::Execute(const ExecutionContext& context)
 			auto& pipelines = material->pipelines;
 			for (auto pipeline : pipelines)
 			{
-				DrawSimple draw;
+				DrawDesc draw;
 				draw.pipeline = pipeline->pipeline;
 				draw.properties = pipeline->properties;
 				draw.vertexBuffer = mesh->vertexBuffer;
 				
-				graphicsModule->RecordSetBuffer(context, draw.properties, "_PerCameraData", camera->perCameraStorage->buffer);
-				graphicsModule->RecordSetBuffer(context, draw.properties, "_PerMeshData", meshRenderer->perMeshStorage->buffer);
+				//graphicsModule->RecSetBuffer(context, draw.properties, "_perCameraData", camera->perCameraStorage->buffer);
+				graphicsModule->RecSetBuffer(context, draw.properties, "_perMeshData", meshRenderer->perMeshStorage->buffer);
 				
 				for (auto& subMesh : mesh->subMeshes)
 				{
 					draw.offset = subMesh.offset;
 					draw.size = subMesh.size;
-					graphicsModule->RecordBindDrawSimple(context, draw);
+					graphicsModule->RecDraw(context, draw);
 				}
 			}
 		}
 
-		graphicsModule->RecordPopDebug(context);
+		graphicsModule->RecPopDebug(context);
 	}
 
 	auto& views = viewModule->GetViews();
 	for (auto view : views)
 	{
-		graphicsModule->RecordFinalBlit(context, view->swapChain, view->renderTarget->texture);
+		graphicsModule->RecFinalBlit(context, view->swapChain, view->renderTarget->texture);
 	}
 
 	for (auto view : views)
 	{
-		graphicsModule->RecordPresent(context, view->swapChain, view->renderTarget->texture);
+		graphicsModule->RecPresent(context, view->swapChain, view->renderTarget->texture);
 	}
 }
\ No newline at end of file
diff --git a/Source/Rendering/UnlitRenderingLoop/UnlitRenderingLoopModule.h b/Source/Rendering/UnlitRenderingLoop/UnlitRenderingLoopModule.h
index 0c5b6ed..031f228 100644
--- a/Source/Rendering/UnlitRenderingLoop/UnlitRenderingLoopModule.h
+++ b/Source/Rendering/UnlitRenderingLoop/UnlitRenderingLoopModule.h
@@ -7,6 +7,7 @@
 #include <Rendering\MeshRendererModule.h>
 #include <Views\IViewModule.h>
 
+class StorageModule;
 class MaterialModule;
 
 class UnlitRenderingLoopModule : public CmdModule
@@ -25,4 +26,5 @@ private:
 	IGraphicsModule* graphicsModule;
 	IViewModule* viewModule;
 	MaterialModule* materialModule;
+	StorageModule* storageModule;
 };
\ No newline at end of file
diff --git a/Source/Transforms/TransformModule.cpp b/Source/Transforms/TransformModule.cpp
index a99669f..85561cb 100644
--- a/Source/Transforms/TransformModule.cpp
+++ b/Source/Transforms/TransformModule.cpp
@@ -66,7 +66,7 @@ bool TransformModule::ExecuteCommand(const ExecutionContext& context, IOStream&
 		for (auto child : transform->childs)
 		{
 			auto unit = child->unit;
-			unit->module->RecordDestroy(context, unit);
+			unit->module->RecDestroy(context, unit);
 		}
 		DESERIALIZE_METHOD_END;
 
diff --git a/Source/Transforms/TransformModule.h b/Source/Transforms/TransformModule.h
index 79a365b..a54d5db 100644
--- a/Source/Transforms/TransformModule.h
+++ b/Source/Transforms/TransformModule.h
@@ -32,11 +32,11 @@ public:
 	TransformModule(uint32_t bufferCount, uint32_t workersCount);
 	virtual void Execute(const ExecutionContext& context) override;
 
-	const Transform* RecordCreateTransform(const ExecutionContext& context);
-	virtual void RecordDestroy(const ExecutionContext& context, const Component* unit) override;
-	void RecordSetParent(const ExecutionContext& context, const Transform* target, const Transform* parent);
-	void RecordSetPosition(const ExecutionContext& context, const Transform* target, const Vector3f& position);
-	void RecordCalculateWorldToView(const ExecutionContext& context, const Transform* target);
+	const Transform* RecCreateTransform(const ExecutionContext& context);
+	virtual void RecDestroy(const ExecutionContext& context, const Component* unit) override;
+	void RecSetParent(const ExecutionContext& context, const Transform* target, const Transform* parent);
+	void RecSetPosition(const ExecutionContext& context, const Transform* target, const Vector3f& position);
+	void RecCalculateWorldToView(const ExecutionContext& context, const Transform* target);
 
 protected:
 	virtual bool ExecuteCommand(const ExecutionContext& context, IOStream& stream, uint32_t commandCode) override;
diff --git a/Source/Views/IViewModule.h b/Source/Views/IViewModule.h
index cfba243..3d654d9 100644
--- a/Source/Views/IViewModule.h
+++ b/Source/Views/IViewModule.h
@@ -21,6 +21,6 @@ class IViewModule : public CmdModule
 {
 public:
 	IViewModule(uint32_t bufferCount, uint32_t workersCount) : CmdModule(bufferCount, workersCount) {}
-	virtual const IView* RecordCreateIView(const ExecutionContext& context) = 0;
+	virtual const IView* RecCreateIView(const ExecutionContext& context) = 0;
 	virtual const List<const IView*>& GetViews() = 0;
 };
\ No newline at end of file
diff --git a/Source/WindowsPlayer/Main.cpp b/Source/WindowsPlayer/Main.cpp
index 8ea51f0..4e8af92 100644
--- a/Source/WindowsPlayer/Main.cpp
+++ b/Source/WindowsPlayer/Main.cpp
@@ -51,14 +51,14 @@ public:
 		auto source =
 			R"(
 
-cbuffer PerCameraData : register(b0)
+cbuffer _perCameraData : register(b0)
 {
-	float4x4 worldToCamera;
+	float4x4 _worldToCamera;
 };
 
-cbuffer PerMeshData : register(b1)
+cbuffer _perMeshData : register(b1)
 {
-	float4x4 objectToWorld;
+	float4x4 _objectToWorld;
 };
 
 struct AppData
@@ -74,7 +74,7 @@ struct VertData
 VertData VertMain(AppData i)
 {
 	VertData o;
-	o.position = mul(worldToCamera, mul(objectToWorld, i.position));
+	o.position = mul(_worldToCamera, mul(_objectToWorld, i.position));
 	return o;
 }
 
@@ -85,40 +85,40 @@ float4 FragMain(VertData i) : SV_TARGET
 			)";
 
 		VertexLayout vertexLayout;
-		vertexLayout.attributes.push_back(VertexAttributeLayout(kVertexAttributeTypePosition, kColorFormatR32G32B32A32));
+		vertexLayout.attributes.push_back(VertexAttributeLayout(VertexAttributeTypePosition, ColorFormatR32G32B32A32));
 
 		auto shaderDesc = new ShaderPipelineDesc();
 		shaderDesc->name = "Test";
 		shaderDesc->source = (const uint8_t*) source;
 		shaderDesc->sourceSize = strlen(source);
-		shaderDesc->states.zTest = kZTestLEqual;
-		shaderDesc->states.zWrite = kZWriteOn;
+		shaderDesc->states.zTest = ZTestLEqual;
+		shaderDesc->states.zWrite = ZWriteOn;
 		shaderDesc->varation = 0;
 		shaderDesc->vertexLayout = vertexLayout;
-		shaderDesc->parameters.push_back(ShaderParameter("_PerCameraData", kShaderParameterTypeConstantBuffer));
-		shaderDesc->parameters.push_back(ShaderParameter("_PerMeshData", kShaderParameterTypeConstantBuffer));
+		shaderDesc->parameters.push_back(ShaderParameter("_perCameraData", ShaderParameterTypeConstantBuffer));
+		shaderDesc->parameters.push_back(ShaderParameter("_perMeshData", ShaderParameterTypeConstantBuffer));
 
-		auto shader = shaderModule->RecordCreateShader(context);
-		shaderModule->RecordSetShaderPipeline(context, shader, 0, shaderDesc);
+		auto shader = shaderModule->RecCreateShader(context);
+		shaderModule->RecSetShaderPipeline(context, shader, 0, shaderDesc);
 		return shader;
 	}
 
 	const Unit* CreateQuad(const ExecutionContext& context, const Shader* shader, const Mesh* mesh, Vector3f position)
 	{
-		auto triangle = unitModule->RecordCreateUnit(context);
+		auto triangle = unitModule->RecCreateUnit(context);
 
 		// Create transform
-		auto transform = transformModuke->RecordCreateTransform(context);
-		transformModuke->RecordSetPosition(context, transform, position);
-		unitModule->RecordAddComponent(context, triangle, transform);
+		auto transform = transformModuke->RecCreateTransform(context);
+		transformModuke->RecSetPosition(context, transform, position);
+		unitModule->RecAddComponent(context, triangle, transform);
 
-		auto material = materialModule->RecordCreateMaterial(context);
-		materialModule->RecordSetShader(context, material, shader);
+		auto material = materialModule->RecCreateMaterial(context);
+		materialModule->RecSetShader(context, material, shader);
 
-		auto meshRenderer = meshRendererModule->RecordCreateMeshRenderer(context);
-		meshRendererModule->RecordSetMaterial(context, meshRenderer, material);
-		meshRendererModule->RecordSetMesh(context, meshRenderer, mesh);
-		unitModule->RecordAddComponent(context, triangle, meshRenderer);
+		auto meshRenderer = meshRendererModule->RecCreateMeshRenderer(context);
+		meshRendererModule->RecSetMaterial(context, meshRenderer, material);
+		meshRendererModule->RecSetMesh(context, meshRenderer, mesh);
+		unitModule->RecAddComponent(context, triangle, meshRenderer);
 		return triangle;
 	}
 
@@ -135,11 +135,11 @@ float4 FragMain(VertData i) : SV_TARGET
 		};
 
 		VertexLayout vertexLayout;
-		vertexLayout.attributes.push_back(VertexAttributeLayout(kVertexAttributeTypePosition, kColorFormatR32G32B32A32));
+		vertexLayout.attributes.push_back(VertexAttributeLayout(VertexAttributeTypePosition, ColorFormatR32G32B32A32));
 
-		auto mesh = meshModule->RecordCreateMesh(context, vertexLayout);
-		meshModule->RecordSetVertices(context, mesh, Range<uint8_t>((uint8_t*) vertices, sizeof(vertices)));
-		meshModule->RecordSetSubMesh(context, mesh, 0, SubMesh(6));
+		auto mesh = meshModule->RecCreateMesh(context, vertexLayout);
+		meshModule->RecSetVertices(context, mesh, Range<uint8_t>((uint8_t*) vertices, sizeof(vertices)));
+		meshModule->RecSetSubMesh(context, mesh, 0, SubMesh(6));
 		return mesh;
 	}
 
@@ -150,74 +150,74 @@ float4 FragMain(VertData i) : SV_TARGET
 		if (frame != 0)
 		{
 			auto transform = unitModule->GetComponent<Transform>(movingCamera);
-			transformModuke->RecordSetPosition(context, transform, transform->localPosition + Vector3f(Math::Sin(frame / 10.0f), 0, 0));
+			transformModuke->RecSetPosition(context, transform, transform->localPosition + Vector3f(Math::Sin(frame / 10.0f), 0, 0));
 			return;
 		}
 
 		// Create window
-		//auto view = viewModule->RecordCreateIView(context);
-		//auto view2 = viewModule->RecordCreateIView(context);
+		//auto view = viewModule->RecCreateIView(context);
+		//auto view2 = viewModule->RecCreateIView(context);
 
 		/*{
-			auto mainCamera = unitModule->RecordCreateUnit(context);
+			auto mainCamera = unitModule->RecCreateUnit(context);
 
 			// Create transform
-			auto transform = transformModuke->RecordCreateTransform(context);
-			transformModuke->RecordSetPosition(context, transform, Vector3f(0, 0, -1));
-			unitModule->RecordAddComponent(context, mainCamera, transform);
+			auto transform = transformModuke->RecCreateTransform(context);
+			transformModuke->RecSetPosition(context, transform, Vector3f(0, 0, -1));
+			unitModule->RecAddComponent(context, mainCamera, transform);
 
 			// Create camera with window as target
-			auto surface = surfaceModule->RecordCreateSurface(context);
-			surfaceModule->RecordSetColor(context, surface, 0, SurfaceColor(view->renderTarget, kLoadActionClear, kStoreActionStore));
-			surfaceModule->RecordSetViewport(context, surface, Viewport(Rectf(0.5f, 0, 0.5f, 1)));
-			auto camera = cameraModule->RecordCreateCamera(context);
-			cameraModule->RecordSetSurface(context, camera, surface);
-			unitModule->RecordAddComponent(context, mainCamera, camera);
+			auto surface = surfaceModule->RecCreateSurface(context);
+			surfaceModule->RecSetColor(context, surface, 0, SurfaceColor(view->renderTarget, LoadActionClear, StoreActionStore));
+			surfaceModule->RecSetViewport(context, surface, Viewport(Rectf(0.5f, 0, 0.5f, 1)));
+			auto camera = cameraModule->RecCreateCamera(context);
+			cameraModule->RecSetSurface(context, camera, surface);
+			unitModule->RecAddComponent(context, mainCamera, camera);
 		}
 
 		{
-			auto mainCamera = unitModule->RecordCreateUnit(context);
+			auto mainCamera = unitModule->RecCreateUnit(context);
 
 			// Create transform
-			auto transform = transformModuke->RecordCreateTransform(context);
-			transformModuke->RecordSetPosition(context, transform, Vector3f(0, 0, -10));
-			unitModule->RecordAddComponent(context, mainCamera, transform);
+			auto transform = transformModuke->RecCreateTransform(context);
+			transformModuke->RecSetPosition(context, transform, Vector3f(0, 0, -10));
+			unitModule->RecAddComponent(context, mainCamera, transform);
 
 			// Create camera with window as target
-			auto surface = surfaceModule->RecordCreateSurface(context);
-			surfaceModule->RecordSetColor(context, surface, 0, SurfaceColor(view->renderTarget, kLoadActionLoad, kStoreActionStore));
-			surfaceModule->RecordSetViewport(context, surface, Viewport(Rectf(0, 0, 0.5f, 1)));
-			auto camera = cameraModule->RecordCreateCamera(context);
-			cameraModule->RecordSetSurface(context, camera, surface);
-			unitModule->RecordAddComponent(context, mainCamera, camera);
+			auto surface = surfaceModule->RecCreateSurface(context);
+			surfaceModule->RecSetColor(context, surface, 0, SurfaceColor(view->renderTarget, LoadActionLoad, StoreActionStore));
+			surfaceModule->RecSetViewport(context, surface, Viewport(Rectf(0, 0, 0.5f, 1)));
+			auto camera = cameraModule->RecCreateCamera(context);
+			cameraModule->RecSetSurface(context, camera, surface);
+			unitModule->RecAddComponent(context, mainCamera, camera);
 		}*/
 
-		for (int i = 0; i < 2; i++)
+		for (int i = 0; i < 1; i++)
 		{
-			auto view = viewModule->RecordCreateIView(context);
+			auto view = viewModule->RecCreateIView(context);
 
-			auto mainCamera = unitModule->RecordCreateUnit(context);
+			auto mainCamera = unitModule->RecCreateUnit(context);
 			movingCamera = mainCamera;
 
 			// Create transform
-			auto transform = transformModuke->RecordCreateTransform(context);
-			transformModuke->RecordSetPosition(context, transform, Vector3f(0, 0, -10));
-			unitModule->RecordAddComponent(context, mainCamera, transform);
+			auto transform = transformModuke->RecCreateTransform(context);
+			transformModuke->RecSetPosition(context, transform, Vector3f(0, 0, -10));
+			unitModule->RecAddComponent(context, mainCamera, transform);
 
 			// Create camera with window as target
-			auto surface = surfaceModule->RecordCreateSurface(context);
-			surfaceModule->RecordSetColor(context, surface, 0, SurfaceColor(view->renderTarget, kLoadActionClear, kStoreActionStore));
-			surfaceModule->RecordSetViewport(context, surface, Viewport(Rectf(0, 0, 1, 1)));
-			auto camera = cameraModule->RecordCreateCamera(context);
-			cameraModule->RecordSetSurface(context, camera, surface);
-			unitModule->RecordAddComponent(context, mainCamera, camera);
+			auto surface = surfaceModule->RecCreateSurface(context);
+			surfaceModule->RecSetColor(context, surface, 0, SurfaceColor(view->renderTarget, LoadActionClear, StoreActionStore));
+			surfaceModule->RecSetViewport(context, surface, Viewport(Rectf(0, 0, 1, 1)));
+			auto camera = cameraModule->RecCreateCamera(context);
+			cameraModule->RecSetSurface(context, camera, surface);
+			unitModule->RecAddComponent(context, mainCamera, camera);
 		}
 
 		auto testShader = CreateShader(context);
 		auto mesh = CreateMesh(context);
-		for (int i = 0; i < 25; i++)
+		for (int i = 0; i < 100; i++)
 		{
-			for (int j = 0; j < 25; j++)
+			for (int j = 0; j < 100; j++)
 			{
 				auto quad = CreateQuad(context, testShader, mesh, Vector3f(i*2, j*2, 0));
 			}
diff --git a/Source/WindowsPlayer/Views/WinViewModule.cpp b/Source/WindowsPlayer/Views/WinViewModule.cpp
index 22940b4..820ca51 100644
--- a/Source/WindowsPlayer/Views/WinViewModule.cpp
+++ b/Source/WindowsPlayer/Views/WinViewModule.cpp
@@ -96,19 +96,19 @@ void WinViewModule::Execute(const ExecutionContext& context)
 }
 
 DECLARE_COMMAND_CODE(CreateIView);
-const IView* WinViewModule::RecordCreateIView(const ExecutionContext& context)
+const IView* WinViewModule::RecCreateIView(const ExecutionContext& context)
 {
 	auto buffer = GetRecordingBuffer(context);
 	auto& stream = buffer->stream;
-	auto width = 2096;
-	auto height = 1280;
-	auto renderTarget = imageModule->RecordCreateImage(context, width, height);
+	auto width = 2048;
+	auto height = 1536;
+	auto renderTarget = imageModule->RecCreateImage(context, width, height);
 	auto target = new WinView(renderTarget);
 	target->width = width;
 	target->height = height;
-	auto swapChain = graphicsModule->RecordCreateISwapChain(context, target);
+	auto swapChain = graphicsModule->RecCreateISwapChain(context, target);
 	target->swapChain = swapChain;
-	stream.Write(kCommandCodeCreateIView);
+	stream.Write(CommandCodeCreateIView);
 	stream.Write(target);
 	buffer->commandCount++;
 	return target;
diff --git a/Source/WindowsPlayer/Views/WinViewModule.h b/Source/WindowsPlayer/Views/WinViewModule.h
index 1b60f0d..770d1cd 100644
--- a/Source/WindowsPlayer/Views/WinViewModule.h
+++ b/Source/WindowsPlayer/Views/WinViewModule.h
@@ -19,7 +19,7 @@ public:
 	WinViewModule(uint32_t bufferCount, uint32_t workersCount, HINSTANCE instanceHandle);
 	virtual void SetupExecuteOrder(ModuleManager* moduleManager) override;
 	virtual void Execute(const ExecutionContext& context) override;
-	virtual const IView* RecordCreateIView(const ExecutionContext& context) override;
+	virtual const IView* RecCreateIView(const ExecutionContext& context) override;
 	virtual const List<const IView*>& GetViews() override;
 
 protected:
